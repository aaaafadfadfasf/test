// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cdb_common.proto

#ifndef PROTOBUF_cdb_5fcommon_2eproto__INCLUDED
#define PROTOBUF_cdb_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cdb_5fcommon_2eproto();
void protobuf_AssignDesc_cdb_5fcommon_2eproto();
void protobuf_ShutdownFile_cdb_5fcommon_2eproto();

class MetaDiskStat;
class AllocatorStat;
class ChunkDiskStat;
class ChunkServerStat;

enum ChunkDiskStat_DiskStatus {
  ChunkDiskStat_DiskStatus_MOUNTING = 1,
  ChunkDiskStat_DiskStatus_RUNNING = 2,
  ChunkDiskStat_DiskStatus_EXITING = 3,
  ChunkDiskStat_DiskStatus_DISABLED = 4,
  ChunkDiskStat_DiskStatus_FULL = 5
};
bool ChunkDiskStat_DiskStatus_IsValid(int value);
const ChunkDiskStat_DiskStatus ChunkDiskStat_DiskStatus_DiskStatus_MIN = ChunkDiskStat_DiskStatus_MOUNTING;
const ChunkDiskStat_DiskStatus ChunkDiskStat_DiskStatus_DiskStatus_MAX = ChunkDiskStat_DiskStatus_FULL;
const int ChunkDiskStat_DiskStatus_DiskStatus_ARRAYSIZE = ChunkDiskStat_DiskStatus_DiskStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChunkDiskStat_DiskStatus_descriptor();
inline const ::std::string& ChunkDiskStat_DiskStatus_Name(ChunkDiskStat_DiskStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChunkDiskStat_DiskStatus_descriptor(), value);
}
inline bool ChunkDiskStat_DiskStatus_Parse(
    const ::std::string& name, ChunkDiskStat_DiskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChunkDiskStat_DiskStatus>(
    ChunkDiskStat_DiskStatus_descriptor(), name, value);
}
enum ChunkServerStat_ServerStatus {
  ChunkServerStat_ServerStatus_CONNECTING_TO_META = 1,
  ChunkServerStat_ServerStatus_CONNECTED_TO_META = 2
};
bool ChunkServerStat_ServerStatus_IsValid(int value);
const ChunkServerStat_ServerStatus ChunkServerStat_ServerStatus_ServerStatus_MIN = ChunkServerStat_ServerStatus_CONNECTING_TO_META;
const ChunkServerStat_ServerStatus ChunkServerStat_ServerStatus_ServerStatus_MAX = ChunkServerStat_ServerStatus_CONNECTED_TO_META;
const int ChunkServerStat_ServerStatus_ServerStatus_ARRAYSIZE = ChunkServerStat_ServerStatus_ServerStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChunkServerStat_ServerStatus_descriptor();
inline const ::std::string& ChunkServerStat_ServerStatus_Name(ChunkServerStat_ServerStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChunkServerStat_ServerStatus_descriptor(), value);
}
inline bool ChunkServerStat_ServerStatus_Parse(
    const ::std::string& name, ChunkServerStat_ServerStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChunkServerStat_ServerStatus>(
    ChunkServerStat_ServerStatus_descriptor(), name, value);
}
// ===================================================================

class MetaDiskStat : public ::google::protobuf::Message {
 public:
  MetaDiskStat();
  virtual ~MetaDiskStat();
  
  MetaDiskStat(const MetaDiskStat& from);
  
  inline MetaDiskStat& operator=(const MetaDiskStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaDiskStat& default_instance();
  
  void Swap(MetaDiskStat* other);
  
  // implements Message ----------------------------------------------
  
  MetaDiskStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaDiskStat& from);
  void MergeFrom(const MetaDiskStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string disk_uuid = 1;
  inline bool has_disk_uuid() const;
  inline void clear_disk_uuid();
  static const int kDiskUuidFieldNumber = 1;
  inline const ::std::string& disk_uuid() const;
  inline void set_disk_uuid(const ::std::string& value);
  inline void set_disk_uuid(const char* value);
  inline void set_disk_uuid(const char* value, size_t size);
  inline ::std::string* mutable_disk_uuid();
  inline ::std::string* release_disk_uuid();
  
  // required string disk_name = 2;
  inline bool has_disk_name() const;
  inline void clear_disk_name();
  static const int kDiskNameFieldNumber = 2;
  inline const ::std::string& disk_name() const;
  inline void set_disk_name(const ::std::string& value);
  inline void set_disk_name(const char* value);
  inline void set_disk_name(const char* value, size_t size);
  inline ::std::string* mutable_disk_name();
  inline ::std::string* release_disk_name();
  
  // optional uint64 total_bytes = 3;
  inline bool has_total_bytes() const;
  inline void clear_total_bytes();
  static const int kTotalBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 total_bytes() const;
  inline void set_total_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 free_bytes = 4;
  inline bool has_free_bytes() const;
  inline void clear_free_bytes();
  static const int kFreeBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 free_bytes() const;
  inline void set_free_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 num_failed_writes = 5;
  inline bool has_num_failed_writes() const;
  inline void clear_num_failed_writes();
  static const int kNumFailedWritesFieldNumber = 5;
  inline ::google::protobuf::uint64 num_failed_writes() const;
  inline void set_num_failed_writes(::google::protobuf::uint64 value);
  
  // optional uint64 num_failed_reads = 6;
  inline bool has_num_failed_reads() const;
  inline void clear_num_failed_reads();
  static const int kNumFailedReadsFieldNumber = 6;
  inline ::google::protobuf::uint64 num_failed_reads() const;
  inline void set_num_failed_reads(::google::protobuf::uint64 value);
  
  // optional uint32 disk_id = 7;
  inline bool has_disk_id() const;
  inline void clear_disk_id();
  static const int kDiskIdFieldNumber = 7;
  inline ::google::protobuf::uint32 disk_id() const;
  inline void set_disk_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MetaDiskStat)
 private:
  inline void set_has_disk_uuid();
  inline void clear_has_disk_uuid();
  inline void set_has_disk_name();
  inline void clear_has_disk_name();
  inline void set_has_total_bytes();
  inline void clear_has_total_bytes();
  inline void set_has_free_bytes();
  inline void clear_has_free_bytes();
  inline void set_has_num_failed_writes();
  inline void clear_has_num_failed_writes();
  inline void set_has_num_failed_reads();
  inline void clear_has_num_failed_reads();
  inline void set_has_disk_id();
  inline void clear_has_disk_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* disk_uuid_;
  ::std::string* disk_name_;
  ::google::protobuf::uint64 total_bytes_;
  ::google::protobuf::uint64 free_bytes_;
  ::google::protobuf::uint64 num_failed_writes_;
  ::google::protobuf::uint64 num_failed_reads_;
  ::google::protobuf::uint32 disk_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fcommon_2eproto();
  friend void protobuf_AssignDesc_cdb_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fcommon_2eproto();
  
  void InitAsDefaultInstance();
  static MetaDiskStat* default_instance_;
};
// -------------------------------------------------------------------

class AllocatorStat : public ::google::protobuf::Message {
 public:
  AllocatorStat();
  virtual ~AllocatorStat();
  
  AllocatorStat(const AllocatorStat& from);
  
  inline AllocatorStat& operator=(const AllocatorStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocatorStat& default_instance();
  
  void Swap(AllocatorStat* other);
  
  // implements Message ----------------------------------------------
  
  AllocatorStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllocatorStat& from);
  void MergeFrom(const AllocatorStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 stripe_blocks = 1;
  inline bool has_stripe_blocks() const;
  inline void clear_stripe_blocks();
  static const int kStripeBlocksFieldNumber = 1;
  inline ::google::protobuf::uint32 stripe_blocks() const;
  inline void set_stripe_blocks(::google::protobuf::uint32 value);
  
  // optional uint32 block_size = 2;
  inline bool has_block_size() const;
  inline void clear_block_size();
  static const int kBlockSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 block_size() const;
  inline void set_block_size(::google::protobuf::uint32 value);
  
  // optional uint32 meta_total_stripes = 3;
  inline bool has_meta_total_stripes() const;
  inline void clear_meta_total_stripes();
  static const int kMetaTotalStripesFieldNumber = 3;
  inline ::google::protobuf::uint32 meta_total_stripes() const;
  inline void set_meta_total_stripes(::google::protobuf::uint32 value);
  
  // optional uint32 meta_free_stripes = 4;
  inline bool has_meta_free_stripes() const;
  inline void clear_meta_free_stripes();
  static const int kMetaFreeStripesFieldNumber = 4;
  inline ::google::protobuf::uint32 meta_free_stripes() const;
  inline void set_meta_free_stripes(::google::protobuf::uint32 value);
  
  // optional uint32 data_total_stripes = 5;
  inline bool has_data_total_stripes() const;
  inline void clear_data_total_stripes();
  static const int kDataTotalStripesFieldNumber = 5;
  inline ::google::protobuf::uint32 data_total_stripes() const;
  inline void set_data_total_stripes(::google::protobuf::uint32 value);
  
  // optional uint32 data_free_stripes = 6;
  inline bool has_data_free_stripes() const;
  inline void clear_data_free_stripes();
  static const int kDataFreeStripesFieldNumber = 6;
  inline ::google::protobuf::uint32 data_free_stripes() const;
  inline void set_data_free_stripes(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:AllocatorStat)
 private:
  inline void set_has_stripe_blocks();
  inline void clear_has_stripe_blocks();
  inline void set_has_block_size();
  inline void clear_has_block_size();
  inline void set_has_meta_total_stripes();
  inline void clear_has_meta_total_stripes();
  inline void set_has_meta_free_stripes();
  inline void clear_has_meta_free_stripes();
  inline void set_has_data_total_stripes();
  inline void clear_has_data_total_stripes();
  inline void set_has_data_free_stripes();
  inline void clear_has_data_free_stripes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 stripe_blocks_;
  ::google::protobuf::uint32 block_size_;
  ::google::protobuf::uint32 meta_total_stripes_;
  ::google::protobuf::uint32 meta_free_stripes_;
  ::google::protobuf::uint32 data_total_stripes_;
  ::google::protobuf::uint32 data_free_stripes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fcommon_2eproto();
  friend void protobuf_AssignDesc_cdb_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fcommon_2eproto();
  
  void InitAsDefaultInstance();
  static AllocatorStat* default_instance_;
};
// -------------------------------------------------------------------

class ChunkDiskStat : public ::google::protobuf::Message {
 public:
  ChunkDiskStat();
  virtual ~ChunkDiskStat();
  
  ChunkDiskStat(const ChunkDiskStat& from);
  
  inline ChunkDiskStat& operator=(const ChunkDiskStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChunkDiskStat& default_instance();
  
  void Swap(ChunkDiskStat* other);
  
  // implements Message ----------------------------------------------
  
  ChunkDiskStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChunkDiskStat& from);
  void MergeFrom(const ChunkDiskStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ChunkDiskStat_DiskStatus DiskStatus;
  static const DiskStatus MOUNTING = ChunkDiskStat_DiskStatus_MOUNTING;
  static const DiskStatus RUNNING = ChunkDiskStat_DiskStatus_RUNNING;
  static const DiskStatus EXITING = ChunkDiskStat_DiskStatus_EXITING;
  static const DiskStatus DISABLED = ChunkDiskStat_DiskStatus_DISABLED;
  static const DiskStatus FULL = ChunkDiskStat_DiskStatus_FULL;
  static inline bool DiskStatus_IsValid(int value) {
    return ChunkDiskStat_DiskStatus_IsValid(value);
  }
  static const DiskStatus DiskStatus_MIN =
    ChunkDiskStat_DiskStatus_DiskStatus_MIN;
  static const DiskStatus DiskStatus_MAX =
    ChunkDiskStat_DiskStatus_DiskStatus_MAX;
  static const int DiskStatus_ARRAYSIZE =
    ChunkDiskStat_DiskStatus_DiskStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DiskStatus_descriptor() {
    return ChunkDiskStat_DiskStatus_descriptor();
  }
  static inline const ::std::string& DiskStatus_Name(DiskStatus value) {
    return ChunkDiskStat_DiskStatus_Name(value);
  }
  static inline bool DiskStatus_Parse(const ::std::string& name,
      DiskStatus* value) {
    return ChunkDiskStat_DiskStatus_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 disk_id = 1;
  inline bool has_disk_id() const;
  inline void clear_disk_id();
  static const int kDiskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 disk_id() const;
  inline void set_disk_id(::google::protobuf::uint32 value);
  
  // required .ChunkDiskStat.DiskStatus status = 2 [default = RUNNING];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::ChunkDiskStat_DiskStatus status() const;
  inline void set_status(::ChunkDiskStat_DiskStatus value);
  
  // required string disk_uuid = 3;
  inline bool has_disk_uuid() const;
  inline void clear_disk_uuid();
  static const int kDiskUuidFieldNumber = 3;
  inline const ::std::string& disk_uuid() const;
  inline void set_disk_uuid(const ::std::string& value);
  inline void set_disk_uuid(const char* value);
  inline void set_disk_uuid(const char* value, size_t size);
  inline ::std::string* mutable_disk_uuid();
  inline ::std::string* release_disk_uuid();
  
  // required string disk_name = 4;
  inline bool has_disk_name() const;
  inline void clear_disk_name();
  static const int kDiskNameFieldNumber = 4;
  inline const ::std::string& disk_name() const;
  inline void set_disk_name(const ::std::string& value);
  inline void set_disk_name(const char* value);
  inline void set_disk_name(const char* value, size_t size);
  inline ::std::string* mutable_disk_name();
  inline ::std::string* release_disk_name();
  
  // optional uint64 total_bytes = 5;
  inline bool has_total_bytes() const;
  inline void clear_total_bytes();
  static const int kTotalBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 total_bytes() const;
  inline void set_total_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 free_bytes = 6;
  inline bool has_free_bytes() const;
  inline void clear_free_bytes();
  static const int kFreeBytesFieldNumber = 6;
  inline ::google::protobuf::uint64 free_bytes() const;
  inline void set_free_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 num_failed_writes = 7;
  inline bool has_num_failed_writes() const;
  inline void clear_num_failed_writes();
  static const int kNumFailedWritesFieldNumber = 7;
  inline ::google::protobuf::uint64 num_failed_writes() const;
  inline void set_num_failed_writes(::google::protobuf::uint64 value);
  
  // optional uint64 num_failed_reads = 8;
  inline bool has_num_failed_reads() const;
  inline void clear_num_failed_reads();
  static const int kNumFailedReadsFieldNumber = 8;
  inline ::google::protobuf::uint64 num_failed_reads() const;
  inline void set_num_failed_reads(::google::protobuf::uint64 value);
  
  // optional .AllocatorStat allocator = 9;
  inline bool has_allocator() const;
  inline void clear_allocator();
  static const int kAllocatorFieldNumber = 9;
  inline const ::AllocatorStat& allocator() const;
  inline ::AllocatorStat* mutable_allocator();
  inline ::AllocatorStat* release_allocator();
  
  // optional uint64 normal_req_bytes_dropped = 10;
  inline bool has_normal_req_bytes_dropped() const;
  inline void clear_normal_req_bytes_dropped();
  static const int kNormalReqBytesDroppedFieldNumber = 10;
  inline ::google::protobuf::uint64 normal_req_bytes_dropped() const;
  inline void set_normal_req_bytes_dropped(::google::protobuf::uint64 value);
  
  // optional uint64 reserv_req_bytes_dropped = 11;
  inline bool has_reserv_req_bytes_dropped() const;
  inline void clear_reserv_req_bytes_dropped();
  static const int kReservReqBytesDroppedFieldNumber = 11;
  inline ::google::protobuf::uint64 reserv_req_bytes_dropped() const;
  inline void set_reserv_req_bytes_dropped(::google::protobuf::uint64 value);
  
  // optional uint64 normal_req_bytes_dropped_interval = 12;
  inline bool has_normal_req_bytes_dropped_interval() const;
  inline void clear_normal_req_bytes_dropped_interval();
  static const int kNormalReqBytesDroppedIntervalFieldNumber = 12;
  inline ::google::protobuf::uint64 normal_req_bytes_dropped_interval() const;
  inline void set_normal_req_bytes_dropped_interval(::google::protobuf::uint64 value);
  
  // optional uint64 reserv_req_bytes_dropped_interval = 13;
  inline bool has_reserv_req_bytes_dropped_interval() const;
  inline void clear_reserv_req_bytes_dropped_interval();
  static const int kReservReqBytesDroppedIntervalFieldNumber = 13;
  inline ::google::protobuf::uint64 reserv_req_bytes_dropped_interval() const;
  inline void set_reserv_req_bytes_dropped_interval(::google::protobuf::uint64 value);
  
  // optional uint32 req_pending_queue_depth = 14;
  inline bool has_req_pending_queue_depth() const;
  inline void clear_req_pending_queue_depth();
  static const int kReqPendingQueueDepthFieldNumber = 14;
  inline ::google::protobuf::uint32 req_pending_queue_depth() const;
  inline void set_req_pending_queue_depth(::google::protobuf::uint32 value);
  
  // optional uint32 aio_pending_queue_depth = 15;
  inline bool has_aio_pending_queue_depth() const;
  inline void clear_aio_pending_queue_depth();
  static const int kAioPendingQueueDepthFieldNumber = 15;
  inline ::google::protobuf::uint32 aio_pending_queue_depth() const;
  inline void set_aio_pending_queue_depth(::google::protobuf::uint32 value);
  
  // optional uint32 defer_queue_depth = 16;
  inline bool has_defer_queue_depth() const;
  inline void clear_defer_queue_depth();
  static const int kDeferQueueDepthFieldNumber = 16;
  inline ::google::protobuf::uint32 defer_queue_depth() const;
  inline void set_defer_queue_depth(::google::protobuf::uint32 value);
  
  // optional uint32 pending_reservations = 17;
  inline bool has_pending_reservations() const;
  inline void clear_pending_reservations();
  static const int kPendingReservationsFieldNumber = 17;
  inline ::google::protobuf::uint32 pending_reservations() const;
  inline void set_pending_reservations(::google::protobuf::uint32 value);
  
  // optional uint64 write_bytes_received = 18;
  inline bool has_write_bytes_received() const;
  inline void clear_write_bytes_received();
  static const int kWriteBytesReceivedFieldNumber = 18;
  inline ::google::protobuf::uint64 write_bytes_received() const;
  inline void set_write_bytes_received(::google::protobuf::uint64 value);
  
  // optional uint64 write_bytes_received_interval = 19;
  inline bool has_write_bytes_received_interval() const;
  inline void clear_write_bytes_received_interval();
  static const int kWriteBytesReceivedIntervalFieldNumber = 19;
  inline ::google::protobuf::uint64 write_bytes_received_interval() const;
  inline void set_write_bytes_received_interval(::google::protobuf::uint64 value);
  
  // optional uint64 write_bytes_redirected = 20;
  inline bool has_write_bytes_redirected() const;
  inline void clear_write_bytes_redirected();
  static const int kWriteBytesRedirectedFieldNumber = 20;
  inline ::google::protobuf::uint64 write_bytes_redirected() const;
  inline void set_write_bytes_redirected(::google::protobuf::uint64 value);
  
  // optional uint64 flush_pending_queue_depth = 21;
  inline bool has_flush_pending_queue_depth() const;
  inline void clear_flush_pending_queue_depth();
  static const int kFlushPendingQueueDepthFieldNumber = 21;
  inline ::google::protobuf::uint64 flush_pending_queue_depth() const;
  inline void set_flush_pending_queue_depth(::google::protobuf::uint64 value);
  
  // optional uint64 flush_queue_depth = 22;
  inline bool has_flush_queue_depth() const;
  inline void clear_flush_queue_depth();
  static const int kFlushQueueDepthFieldNumber = 22;
  inline ::google::protobuf::uint64 flush_queue_depth() const;
  inline void set_flush_queue_depth(::google::protobuf::uint64 value);
  
  // optional uint64 pending_chunk_file_writers = 23;
  inline bool has_pending_chunk_file_writers() const;
  inline void clear_pending_chunk_file_writers();
  static const int kPendingChunkFileWritersFieldNumber = 23;
  inline ::google::protobuf::uint64 pending_chunk_file_writers() const;
  inline void set_pending_chunk_file_writers(::google::protobuf::uint64 value);
  
  // optional uint32 num_disk_repair_read = 24;
  inline bool has_num_disk_repair_read() const;
  inline void clear_num_disk_repair_read();
  static const int kNumDiskRepairReadFieldNumber = 24;
  inline ::google::protobuf::uint32 num_disk_repair_read() const;
  inline void set_num_disk_repair_read(::google::protobuf::uint32 value);
  
  // optional uint32 num_pending_write = 25;
  inline bool has_num_pending_write() const;
  inline void clear_num_pending_write();
  static const int kNumPendingWriteFieldNumber = 25;
  inline ::google::protobuf::uint32 num_pending_write() const;
  inline void set_num_pending_write(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ChunkDiskStat)
 private:
  inline void set_has_disk_id();
  inline void clear_has_disk_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_disk_uuid();
  inline void clear_has_disk_uuid();
  inline void set_has_disk_name();
  inline void clear_has_disk_name();
  inline void set_has_total_bytes();
  inline void clear_has_total_bytes();
  inline void set_has_free_bytes();
  inline void clear_has_free_bytes();
  inline void set_has_num_failed_writes();
  inline void clear_has_num_failed_writes();
  inline void set_has_num_failed_reads();
  inline void clear_has_num_failed_reads();
  inline void set_has_allocator();
  inline void clear_has_allocator();
  inline void set_has_normal_req_bytes_dropped();
  inline void clear_has_normal_req_bytes_dropped();
  inline void set_has_reserv_req_bytes_dropped();
  inline void clear_has_reserv_req_bytes_dropped();
  inline void set_has_normal_req_bytes_dropped_interval();
  inline void clear_has_normal_req_bytes_dropped_interval();
  inline void set_has_reserv_req_bytes_dropped_interval();
  inline void clear_has_reserv_req_bytes_dropped_interval();
  inline void set_has_req_pending_queue_depth();
  inline void clear_has_req_pending_queue_depth();
  inline void set_has_aio_pending_queue_depth();
  inline void clear_has_aio_pending_queue_depth();
  inline void set_has_defer_queue_depth();
  inline void clear_has_defer_queue_depth();
  inline void set_has_pending_reservations();
  inline void clear_has_pending_reservations();
  inline void set_has_write_bytes_received();
  inline void clear_has_write_bytes_received();
  inline void set_has_write_bytes_received_interval();
  inline void clear_has_write_bytes_received_interval();
  inline void set_has_write_bytes_redirected();
  inline void clear_has_write_bytes_redirected();
  inline void set_has_flush_pending_queue_depth();
  inline void clear_has_flush_pending_queue_depth();
  inline void set_has_flush_queue_depth();
  inline void clear_has_flush_queue_depth();
  inline void set_has_pending_chunk_file_writers();
  inline void clear_has_pending_chunk_file_writers();
  inline void set_has_num_disk_repair_read();
  inline void clear_has_num_disk_repair_read();
  inline void set_has_num_pending_write();
  inline void clear_has_num_pending_write();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 disk_id_;
  int status_;
  ::std::string* disk_uuid_;
  ::std::string* disk_name_;
  ::google::protobuf::uint64 total_bytes_;
  ::google::protobuf::uint64 free_bytes_;
  ::google::protobuf::uint64 num_failed_writes_;
  ::google::protobuf::uint64 num_failed_reads_;
  ::AllocatorStat* allocator_;
  ::google::protobuf::uint64 normal_req_bytes_dropped_;
  ::google::protobuf::uint64 reserv_req_bytes_dropped_;
  ::google::protobuf::uint64 normal_req_bytes_dropped_interval_;
  ::google::protobuf::uint64 reserv_req_bytes_dropped_interval_;
  ::google::protobuf::uint32 req_pending_queue_depth_;
  ::google::protobuf::uint32 aio_pending_queue_depth_;
  ::google::protobuf::uint32 defer_queue_depth_;
  ::google::protobuf::uint32 pending_reservations_;
  ::google::protobuf::uint64 write_bytes_received_;
  ::google::protobuf::uint64 write_bytes_received_interval_;
  ::google::protobuf::uint64 write_bytes_redirected_;
  ::google::protobuf::uint64 flush_pending_queue_depth_;
  ::google::protobuf::uint64 flush_queue_depth_;
  ::google::protobuf::uint64 pending_chunk_file_writers_;
  ::google::protobuf::uint32 num_disk_repair_read_;
  ::google::protobuf::uint32 num_pending_write_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fcommon_2eproto();
  friend void protobuf_AssignDesc_cdb_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fcommon_2eproto();
  
  void InitAsDefaultInstance();
  static ChunkDiskStat* default_instance_;
};
// -------------------------------------------------------------------

class ChunkServerStat : public ::google::protobuf::Message {
 public:
  ChunkServerStat();
  virtual ~ChunkServerStat();
  
  ChunkServerStat(const ChunkServerStat& from);
  
  inline ChunkServerStat& operator=(const ChunkServerStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChunkServerStat& default_instance();
  
  void Swap(ChunkServerStat* other);
  
  // implements Message ----------------------------------------------
  
  ChunkServerStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChunkServerStat& from);
  void MergeFrom(const ChunkServerStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ChunkServerStat_ServerStatus ServerStatus;
  static const ServerStatus CONNECTING_TO_META = ChunkServerStat_ServerStatus_CONNECTING_TO_META;
  static const ServerStatus CONNECTED_TO_META = ChunkServerStat_ServerStatus_CONNECTED_TO_META;
  static inline bool ServerStatus_IsValid(int value) {
    return ChunkServerStat_ServerStatus_IsValid(value);
  }
  static const ServerStatus ServerStatus_MIN =
    ChunkServerStat_ServerStatus_ServerStatus_MIN;
  static const ServerStatus ServerStatus_MAX =
    ChunkServerStat_ServerStatus_ServerStatus_MAX;
  static const int ServerStatus_ARRAYSIZE =
    ChunkServerStat_ServerStatus_ServerStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ServerStatus_descriptor() {
    return ChunkServerStat_ServerStatus_descriptor();
  }
  static inline const ::std::string& ServerStatus_Name(ServerStatus value) {
    return ChunkServerStat_ServerStatus_Name(value);
  }
  static inline bool ServerStatus_Parse(const ::std::string& name,
      ServerStatus* value) {
    return ChunkServerStat_ServerStatus_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .ChunkServerStat.ServerStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::ChunkServerStat_ServerStatus status() const;
  inline void set_status(::ChunkServerStat_ServerStatus value);
  
  // required uint32 cs_id = 2;
  inline bool has_cs_id() const;
  inline void clear_cs_id();
  static const int kCsIdFieldNumber = 2;
  inline ::google::protobuf::uint32 cs_id() const;
  inline void set_cs_id(::google::protobuf::uint32 value);
  
  // required bytes cs_uuid = 3;
  inline bool has_cs_uuid() const;
  inline void clear_cs_uuid();
  static const int kCsUuidFieldNumber = 3;
  inline const ::std::string& cs_uuid() const;
  inline void set_cs_uuid(const ::std::string& value);
  inline void set_cs_uuid(const char* value);
  inline void set_cs_uuid(const void* value, size_t size);
  inline ::std::string* mutable_cs_uuid();
  inline ::std::string* release_cs_uuid();
  
  // repeated .ChunkDiskStat stat = 4;
  inline int stat_size() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 4;
  inline const ::ChunkDiskStat& stat(int index) const;
  inline ::ChunkDiskStat* mutable_stat(int index);
  inline ::ChunkDiskStat* add_stat();
  inline const ::google::protobuf::RepeatedPtrField< ::ChunkDiskStat >&
      stat() const;
  inline ::google::protobuf::RepeatedPtrField< ::ChunkDiskStat >*
      mutable_stat();
  
  // optional int64 total_bytes = 5;
  inline bool has_total_bytes() const;
  inline void clear_total_bytes();
  static const int kTotalBytesFieldNumber = 5;
  inline ::google::protobuf::int64 total_bytes() const;
  inline void set_total_bytes(::google::protobuf::int64 value);
  
  // optional int64 free_bytes = 6;
  inline bool has_free_bytes() const;
  inline void clear_free_bytes();
  static const int kFreeBytesFieldNumber = 6;
  inline ::google::protobuf::int64 free_bytes() const;
  inline void set_free_bytes(::google::protobuf::int64 value);
  
  // optional .MetaDiskStat chunk_meta_disk = 7;
  inline bool has_chunk_meta_disk() const;
  inline void clear_chunk_meta_disk();
  static const int kChunkMetaDiskFieldNumber = 7;
  inline const ::MetaDiskStat& chunk_meta_disk() const;
  inline ::MetaDiskStat* mutable_chunk_meta_disk();
  inline ::MetaDiskStat* release_chunk_meta_disk();
  
  // optional uint64 update_timestamp = 8;
  inline bool has_update_timestamp() const;
  inline void clear_update_timestamp();
  static const int kUpdateTimestampFieldNumber = 8;
  inline ::google::protobuf::uint64 update_timestamp() const;
  inline void set_update_timestamp(::google::protobuf::uint64 value);
  
  // optional bytes zone = 9;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 9;
  inline const ::std::string& zone() const;
  inline void set_zone(const ::std::string& value);
  inline void set_zone(const char* value);
  inline void set_zone(const void* value, size_t size);
  inline ::std::string* mutable_zone();
  inline ::std::string* release_zone();
  
  // optional bytes machine_id = 10;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 10;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const void* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  
  // optional bytes internal_cluster_uuid = 11;
  inline bool has_internal_cluster_uuid() const;
  inline void clear_internal_cluster_uuid();
  static const int kInternalClusterUuidFieldNumber = 11;
  inline const ::std::string& internal_cluster_uuid() const;
  inline void set_internal_cluster_uuid(const ::std::string& value);
  inline void set_internal_cluster_uuid(const char* value);
  inline void set_internal_cluster_uuid(const void* value, size_t size);
  inline ::std::string* mutable_internal_cluster_uuid();
  inline ::std::string* release_internal_cluster_uuid();
  
  // optional bytes version = 12;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 12;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional uint32 total_repair_read = 13;
  inline bool has_total_repair_read() const;
  inline void clear_total_repair_read();
  static const int kTotalRepairReadFieldNumber = 13;
  inline ::google::protobuf::uint32 total_repair_read() const;
  inline void set_total_repair_read(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ChunkServerStat)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_cs_id();
  inline void clear_has_cs_id();
  inline void set_has_cs_uuid();
  inline void clear_has_cs_uuid();
  inline void set_has_total_bytes();
  inline void clear_has_total_bytes();
  inline void set_has_free_bytes();
  inline void clear_has_free_bytes();
  inline void set_has_chunk_meta_disk();
  inline void clear_has_chunk_meta_disk();
  inline void set_has_update_timestamp();
  inline void clear_has_update_timestamp();
  inline void set_has_zone();
  inline void clear_has_zone();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_internal_cluster_uuid();
  inline void clear_has_internal_cluster_uuid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_total_repair_read();
  inline void clear_has_total_repair_read();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int status_;
  ::google::protobuf::uint32 cs_id_;
  ::std::string* cs_uuid_;
  ::google::protobuf::RepeatedPtrField< ::ChunkDiskStat > stat_;
  ::google::protobuf::int64 total_bytes_;
  ::google::protobuf::int64 free_bytes_;
  ::MetaDiskStat* chunk_meta_disk_;
  ::google::protobuf::uint64 update_timestamp_;
  ::std::string* zone_;
  ::std::string* machine_id_;
  ::std::string* internal_cluster_uuid_;
  ::std::string* version_;
  ::google::protobuf::uint32 total_repair_read_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fcommon_2eproto();
  friend void protobuf_AssignDesc_cdb_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fcommon_2eproto();
  
  void InitAsDefaultInstance();
  static ChunkServerStat* default_instance_;
};
// ===================================================================


// ===================================================================

// MetaDiskStat

// required string disk_uuid = 1;
inline bool MetaDiskStat::has_disk_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaDiskStat::set_has_disk_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaDiskStat::clear_has_disk_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaDiskStat::clear_disk_uuid() {
  if (disk_uuid_ != &::google::protobuf::internal::kEmptyString) {
    disk_uuid_->clear();
  }
  clear_has_disk_uuid();
}
inline const ::std::string& MetaDiskStat::disk_uuid() const {
  return *disk_uuid_;
}
inline void MetaDiskStat::set_disk_uuid(const ::std::string& value) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(value);
}
inline void MetaDiskStat::set_disk_uuid(const char* value) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(value);
}
inline void MetaDiskStat::set_disk_uuid(const char* value, size_t size) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDiskStat::mutable_disk_uuid() {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  return disk_uuid_;
}
inline ::std::string* MetaDiskStat::release_disk_uuid() {
  clear_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_uuid_;
    disk_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string disk_name = 2;
inline bool MetaDiskStat::has_disk_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaDiskStat::set_has_disk_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaDiskStat::clear_has_disk_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaDiskStat::clear_disk_name() {
  if (disk_name_ != &::google::protobuf::internal::kEmptyString) {
    disk_name_->clear();
  }
  clear_has_disk_name();
}
inline const ::std::string& MetaDiskStat::disk_name() const {
  return *disk_name_;
}
inline void MetaDiskStat::set_disk_name(const ::std::string& value) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(value);
}
inline void MetaDiskStat::set_disk_name(const char* value) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(value);
}
inline void MetaDiskStat::set_disk_name(const char* value, size_t size) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDiskStat::mutable_disk_name() {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  return disk_name_;
}
inline ::std::string* MetaDiskStat::release_disk_name() {
  clear_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_name_;
    disk_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 total_bytes = 3;
inline bool MetaDiskStat::has_total_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaDiskStat::set_has_total_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaDiskStat::clear_has_total_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaDiskStat::clear_total_bytes() {
  total_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_total_bytes();
}
inline ::google::protobuf::uint64 MetaDiskStat::total_bytes() const {
  return total_bytes_;
}
inline void MetaDiskStat::set_total_bytes(::google::protobuf::uint64 value) {
  set_has_total_bytes();
  total_bytes_ = value;
}

// optional uint64 free_bytes = 4;
inline bool MetaDiskStat::has_free_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetaDiskStat::set_has_free_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetaDiskStat::clear_has_free_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetaDiskStat::clear_free_bytes() {
  free_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_free_bytes();
}
inline ::google::protobuf::uint64 MetaDiskStat::free_bytes() const {
  return free_bytes_;
}
inline void MetaDiskStat::set_free_bytes(::google::protobuf::uint64 value) {
  set_has_free_bytes();
  free_bytes_ = value;
}

// optional uint64 num_failed_writes = 5;
inline bool MetaDiskStat::has_num_failed_writes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetaDiskStat::set_has_num_failed_writes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetaDiskStat::clear_has_num_failed_writes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetaDiskStat::clear_num_failed_writes() {
  num_failed_writes_ = GOOGLE_ULONGLONG(0);
  clear_has_num_failed_writes();
}
inline ::google::protobuf::uint64 MetaDiskStat::num_failed_writes() const {
  return num_failed_writes_;
}
inline void MetaDiskStat::set_num_failed_writes(::google::protobuf::uint64 value) {
  set_has_num_failed_writes();
  num_failed_writes_ = value;
}

// optional uint64 num_failed_reads = 6;
inline bool MetaDiskStat::has_num_failed_reads() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetaDiskStat::set_has_num_failed_reads() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetaDiskStat::clear_has_num_failed_reads() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetaDiskStat::clear_num_failed_reads() {
  num_failed_reads_ = GOOGLE_ULONGLONG(0);
  clear_has_num_failed_reads();
}
inline ::google::protobuf::uint64 MetaDiskStat::num_failed_reads() const {
  return num_failed_reads_;
}
inline void MetaDiskStat::set_num_failed_reads(::google::protobuf::uint64 value) {
  set_has_num_failed_reads();
  num_failed_reads_ = value;
}

// optional uint32 disk_id = 7;
inline bool MetaDiskStat::has_disk_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MetaDiskStat::set_has_disk_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MetaDiskStat::clear_has_disk_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MetaDiskStat::clear_disk_id() {
  disk_id_ = 0u;
  clear_has_disk_id();
}
inline ::google::protobuf::uint32 MetaDiskStat::disk_id() const {
  return disk_id_;
}
inline void MetaDiskStat::set_disk_id(::google::protobuf::uint32 value) {
  set_has_disk_id();
  disk_id_ = value;
}

// -------------------------------------------------------------------

// AllocatorStat

// optional uint32 stripe_blocks = 1;
inline bool AllocatorStat::has_stripe_blocks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocatorStat::set_has_stripe_blocks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllocatorStat::clear_has_stripe_blocks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllocatorStat::clear_stripe_blocks() {
  stripe_blocks_ = 0u;
  clear_has_stripe_blocks();
}
inline ::google::protobuf::uint32 AllocatorStat::stripe_blocks() const {
  return stripe_blocks_;
}
inline void AllocatorStat::set_stripe_blocks(::google::protobuf::uint32 value) {
  set_has_stripe_blocks();
  stripe_blocks_ = value;
}

// optional uint32 block_size = 2;
inline bool AllocatorStat::has_block_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocatorStat::set_has_block_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllocatorStat::clear_has_block_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllocatorStat::clear_block_size() {
  block_size_ = 0u;
  clear_has_block_size();
}
inline ::google::protobuf::uint32 AllocatorStat::block_size() const {
  return block_size_;
}
inline void AllocatorStat::set_block_size(::google::protobuf::uint32 value) {
  set_has_block_size();
  block_size_ = value;
}

// optional uint32 meta_total_stripes = 3;
inline bool AllocatorStat::has_meta_total_stripes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllocatorStat::set_has_meta_total_stripes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllocatorStat::clear_has_meta_total_stripes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllocatorStat::clear_meta_total_stripes() {
  meta_total_stripes_ = 0u;
  clear_has_meta_total_stripes();
}
inline ::google::protobuf::uint32 AllocatorStat::meta_total_stripes() const {
  return meta_total_stripes_;
}
inline void AllocatorStat::set_meta_total_stripes(::google::protobuf::uint32 value) {
  set_has_meta_total_stripes();
  meta_total_stripes_ = value;
}

// optional uint32 meta_free_stripes = 4;
inline bool AllocatorStat::has_meta_free_stripes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AllocatorStat::set_has_meta_free_stripes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AllocatorStat::clear_has_meta_free_stripes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AllocatorStat::clear_meta_free_stripes() {
  meta_free_stripes_ = 0u;
  clear_has_meta_free_stripes();
}
inline ::google::protobuf::uint32 AllocatorStat::meta_free_stripes() const {
  return meta_free_stripes_;
}
inline void AllocatorStat::set_meta_free_stripes(::google::protobuf::uint32 value) {
  set_has_meta_free_stripes();
  meta_free_stripes_ = value;
}

// optional uint32 data_total_stripes = 5;
inline bool AllocatorStat::has_data_total_stripes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AllocatorStat::set_has_data_total_stripes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AllocatorStat::clear_has_data_total_stripes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AllocatorStat::clear_data_total_stripes() {
  data_total_stripes_ = 0u;
  clear_has_data_total_stripes();
}
inline ::google::protobuf::uint32 AllocatorStat::data_total_stripes() const {
  return data_total_stripes_;
}
inline void AllocatorStat::set_data_total_stripes(::google::protobuf::uint32 value) {
  set_has_data_total_stripes();
  data_total_stripes_ = value;
}

// optional uint32 data_free_stripes = 6;
inline bool AllocatorStat::has_data_free_stripes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AllocatorStat::set_has_data_free_stripes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AllocatorStat::clear_has_data_free_stripes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AllocatorStat::clear_data_free_stripes() {
  data_free_stripes_ = 0u;
  clear_has_data_free_stripes();
}
inline ::google::protobuf::uint32 AllocatorStat::data_free_stripes() const {
  return data_free_stripes_;
}
inline void AllocatorStat::set_data_free_stripes(::google::protobuf::uint32 value) {
  set_has_data_free_stripes();
  data_free_stripes_ = value;
}

// -------------------------------------------------------------------

// ChunkDiskStat

// required uint32 disk_id = 1;
inline bool ChunkDiskStat::has_disk_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChunkDiskStat::set_has_disk_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChunkDiskStat::clear_has_disk_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChunkDiskStat::clear_disk_id() {
  disk_id_ = 0u;
  clear_has_disk_id();
}
inline ::google::protobuf::uint32 ChunkDiskStat::disk_id() const {
  return disk_id_;
}
inline void ChunkDiskStat::set_disk_id(::google::protobuf::uint32 value) {
  set_has_disk_id();
  disk_id_ = value;
}

// required .ChunkDiskStat.DiskStatus status = 2 [default = RUNNING];
inline bool ChunkDiskStat::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChunkDiskStat::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChunkDiskStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChunkDiskStat::clear_status() {
  status_ = 2;
  clear_has_status();
}
inline ::ChunkDiskStat_DiskStatus ChunkDiskStat::status() const {
  return static_cast< ::ChunkDiskStat_DiskStatus >(status_);
}
inline void ChunkDiskStat::set_status(::ChunkDiskStat_DiskStatus value) {
  GOOGLE_DCHECK(::ChunkDiskStat_DiskStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required string disk_uuid = 3;
inline bool ChunkDiskStat::has_disk_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChunkDiskStat::set_has_disk_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChunkDiskStat::clear_has_disk_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChunkDiskStat::clear_disk_uuid() {
  if (disk_uuid_ != &::google::protobuf::internal::kEmptyString) {
    disk_uuid_->clear();
  }
  clear_has_disk_uuid();
}
inline const ::std::string& ChunkDiskStat::disk_uuid() const {
  return *disk_uuid_;
}
inline void ChunkDiskStat::set_disk_uuid(const ::std::string& value) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(value);
}
inline void ChunkDiskStat::set_disk_uuid(const char* value) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(value);
}
inline void ChunkDiskStat::set_disk_uuid(const char* value, size_t size) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkDiskStat::mutable_disk_uuid() {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  return disk_uuid_;
}
inline ::std::string* ChunkDiskStat::release_disk_uuid() {
  clear_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_uuid_;
    disk_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string disk_name = 4;
inline bool ChunkDiskStat::has_disk_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChunkDiskStat::set_has_disk_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChunkDiskStat::clear_has_disk_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChunkDiskStat::clear_disk_name() {
  if (disk_name_ != &::google::protobuf::internal::kEmptyString) {
    disk_name_->clear();
  }
  clear_has_disk_name();
}
inline const ::std::string& ChunkDiskStat::disk_name() const {
  return *disk_name_;
}
inline void ChunkDiskStat::set_disk_name(const ::std::string& value) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(value);
}
inline void ChunkDiskStat::set_disk_name(const char* value) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(value);
}
inline void ChunkDiskStat::set_disk_name(const char* value, size_t size) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkDiskStat::mutable_disk_name() {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  return disk_name_;
}
inline ::std::string* ChunkDiskStat::release_disk_name() {
  clear_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_name_;
    disk_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 total_bytes = 5;
inline bool ChunkDiskStat::has_total_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChunkDiskStat::set_has_total_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChunkDiskStat::clear_has_total_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChunkDiskStat::clear_total_bytes() {
  total_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_total_bytes();
}
inline ::google::protobuf::uint64 ChunkDiskStat::total_bytes() const {
  return total_bytes_;
}
inline void ChunkDiskStat::set_total_bytes(::google::protobuf::uint64 value) {
  set_has_total_bytes();
  total_bytes_ = value;
}

// optional uint64 free_bytes = 6;
inline bool ChunkDiskStat::has_free_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChunkDiskStat::set_has_free_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChunkDiskStat::clear_has_free_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChunkDiskStat::clear_free_bytes() {
  free_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_free_bytes();
}
inline ::google::protobuf::uint64 ChunkDiskStat::free_bytes() const {
  return free_bytes_;
}
inline void ChunkDiskStat::set_free_bytes(::google::protobuf::uint64 value) {
  set_has_free_bytes();
  free_bytes_ = value;
}

// optional uint64 num_failed_writes = 7;
inline bool ChunkDiskStat::has_num_failed_writes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChunkDiskStat::set_has_num_failed_writes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChunkDiskStat::clear_has_num_failed_writes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChunkDiskStat::clear_num_failed_writes() {
  num_failed_writes_ = GOOGLE_ULONGLONG(0);
  clear_has_num_failed_writes();
}
inline ::google::protobuf::uint64 ChunkDiskStat::num_failed_writes() const {
  return num_failed_writes_;
}
inline void ChunkDiskStat::set_num_failed_writes(::google::protobuf::uint64 value) {
  set_has_num_failed_writes();
  num_failed_writes_ = value;
}

// optional uint64 num_failed_reads = 8;
inline bool ChunkDiskStat::has_num_failed_reads() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChunkDiskStat::set_has_num_failed_reads() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChunkDiskStat::clear_has_num_failed_reads() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChunkDiskStat::clear_num_failed_reads() {
  num_failed_reads_ = GOOGLE_ULONGLONG(0);
  clear_has_num_failed_reads();
}
inline ::google::protobuf::uint64 ChunkDiskStat::num_failed_reads() const {
  return num_failed_reads_;
}
inline void ChunkDiskStat::set_num_failed_reads(::google::protobuf::uint64 value) {
  set_has_num_failed_reads();
  num_failed_reads_ = value;
}

// optional .AllocatorStat allocator = 9;
inline bool ChunkDiskStat::has_allocator() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChunkDiskStat::set_has_allocator() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChunkDiskStat::clear_has_allocator() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChunkDiskStat::clear_allocator() {
  if (allocator_ != NULL) allocator_->::AllocatorStat::Clear();
  clear_has_allocator();
}
inline const ::AllocatorStat& ChunkDiskStat::allocator() const {
  return allocator_ != NULL ? *allocator_ : *default_instance_->allocator_;
}
inline ::AllocatorStat* ChunkDiskStat::mutable_allocator() {
  set_has_allocator();
  if (allocator_ == NULL) allocator_ = new ::AllocatorStat;
  return allocator_;
}
inline ::AllocatorStat* ChunkDiskStat::release_allocator() {
  clear_has_allocator();
  ::AllocatorStat* temp = allocator_;
  allocator_ = NULL;
  return temp;
}

// optional uint64 normal_req_bytes_dropped = 10;
inline bool ChunkDiskStat::has_normal_req_bytes_dropped() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ChunkDiskStat::set_has_normal_req_bytes_dropped() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ChunkDiskStat::clear_has_normal_req_bytes_dropped() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ChunkDiskStat::clear_normal_req_bytes_dropped() {
  normal_req_bytes_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_normal_req_bytes_dropped();
}
inline ::google::protobuf::uint64 ChunkDiskStat::normal_req_bytes_dropped() const {
  return normal_req_bytes_dropped_;
}
inline void ChunkDiskStat::set_normal_req_bytes_dropped(::google::protobuf::uint64 value) {
  set_has_normal_req_bytes_dropped();
  normal_req_bytes_dropped_ = value;
}

// optional uint64 reserv_req_bytes_dropped = 11;
inline bool ChunkDiskStat::has_reserv_req_bytes_dropped() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ChunkDiskStat::set_has_reserv_req_bytes_dropped() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ChunkDiskStat::clear_has_reserv_req_bytes_dropped() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ChunkDiskStat::clear_reserv_req_bytes_dropped() {
  reserv_req_bytes_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_reserv_req_bytes_dropped();
}
inline ::google::protobuf::uint64 ChunkDiskStat::reserv_req_bytes_dropped() const {
  return reserv_req_bytes_dropped_;
}
inline void ChunkDiskStat::set_reserv_req_bytes_dropped(::google::protobuf::uint64 value) {
  set_has_reserv_req_bytes_dropped();
  reserv_req_bytes_dropped_ = value;
}

// optional uint64 normal_req_bytes_dropped_interval = 12;
inline bool ChunkDiskStat::has_normal_req_bytes_dropped_interval() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ChunkDiskStat::set_has_normal_req_bytes_dropped_interval() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ChunkDiskStat::clear_has_normal_req_bytes_dropped_interval() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ChunkDiskStat::clear_normal_req_bytes_dropped_interval() {
  normal_req_bytes_dropped_interval_ = GOOGLE_ULONGLONG(0);
  clear_has_normal_req_bytes_dropped_interval();
}
inline ::google::protobuf::uint64 ChunkDiskStat::normal_req_bytes_dropped_interval() const {
  return normal_req_bytes_dropped_interval_;
}
inline void ChunkDiskStat::set_normal_req_bytes_dropped_interval(::google::protobuf::uint64 value) {
  set_has_normal_req_bytes_dropped_interval();
  normal_req_bytes_dropped_interval_ = value;
}

// optional uint64 reserv_req_bytes_dropped_interval = 13;
inline bool ChunkDiskStat::has_reserv_req_bytes_dropped_interval() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ChunkDiskStat::set_has_reserv_req_bytes_dropped_interval() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ChunkDiskStat::clear_has_reserv_req_bytes_dropped_interval() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ChunkDiskStat::clear_reserv_req_bytes_dropped_interval() {
  reserv_req_bytes_dropped_interval_ = GOOGLE_ULONGLONG(0);
  clear_has_reserv_req_bytes_dropped_interval();
}
inline ::google::protobuf::uint64 ChunkDiskStat::reserv_req_bytes_dropped_interval() const {
  return reserv_req_bytes_dropped_interval_;
}
inline void ChunkDiskStat::set_reserv_req_bytes_dropped_interval(::google::protobuf::uint64 value) {
  set_has_reserv_req_bytes_dropped_interval();
  reserv_req_bytes_dropped_interval_ = value;
}

// optional uint32 req_pending_queue_depth = 14;
inline bool ChunkDiskStat::has_req_pending_queue_depth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ChunkDiskStat::set_has_req_pending_queue_depth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ChunkDiskStat::clear_has_req_pending_queue_depth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ChunkDiskStat::clear_req_pending_queue_depth() {
  req_pending_queue_depth_ = 0u;
  clear_has_req_pending_queue_depth();
}
inline ::google::protobuf::uint32 ChunkDiskStat::req_pending_queue_depth() const {
  return req_pending_queue_depth_;
}
inline void ChunkDiskStat::set_req_pending_queue_depth(::google::protobuf::uint32 value) {
  set_has_req_pending_queue_depth();
  req_pending_queue_depth_ = value;
}

// optional uint32 aio_pending_queue_depth = 15;
inline bool ChunkDiskStat::has_aio_pending_queue_depth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ChunkDiskStat::set_has_aio_pending_queue_depth() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ChunkDiskStat::clear_has_aio_pending_queue_depth() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ChunkDiskStat::clear_aio_pending_queue_depth() {
  aio_pending_queue_depth_ = 0u;
  clear_has_aio_pending_queue_depth();
}
inline ::google::protobuf::uint32 ChunkDiskStat::aio_pending_queue_depth() const {
  return aio_pending_queue_depth_;
}
inline void ChunkDiskStat::set_aio_pending_queue_depth(::google::protobuf::uint32 value) {
  set_has_aio_pending_queue_depth();
  aio_pending_queue_depth_ = value;
}

// optional uint32 defer_queue_depth = 16;
inline bool ChunkDiskStat::has_defer_queue_depth() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ChunkDiskStat::set_has_defer_queue_depth() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ChunkDiskStat::clear_has_defer_queue_depth() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ChunkDiskStat::clear_defer_queue_depth() {
  defer_queue_depth_ = 0u;
  clear_has_defer_queue_depth();
}
inline ::google::protobuf::uint32 ChunkDiskStat::defer_queue_depth() const {
  return defer_queue_depth_;
}
inline void ChunkDiskStat::set_defer_queue_depth(::google::protobuf::uint32 value) {
  set_has_defer_queue_depth();
  defer_queue_depth_ = value;
}

// optional uint32 pending_reservations = 17;
inline bool ChunkDiskStat::has_pending_reservations() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ChunkDiskStat::set_has_pending_reservations() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ChunkDiskStat::clear_has_pending_reservations() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ChunkDiskStat::clear_pending_reservations() {
  pending_reservations_ = 0u;
  clear_has_pending_reservations();
}
inline ::google::protobuf::uint32 ChunkDiskStat::pending_reservations() const {
  return pending_reservations_;
}
inline void ChunkDiskStat::set_pending_reservations(::google::protobuf::uint32 value) {
  set_has_pending_reservations();
  pending_reservations_ = value;
}

// optional uint64 write_bytes_received = 18;
inline bool ChunkDiskStat::has_write_bytes_received() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ChunkDiskStat::set_has_write_bytes_received() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ChunkDiskStat::clear_has_write_bytes_received() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ChunkDiskStat::clear_write_bytes_received() {
  write_bytes_received_ = GOOGLE_ULONGLONG(0);
  clear_has_write_bytes_received();
}
inline ::google::protobuf::uint64 ChunkDiskStat::write_bytes_received() const {
  return write_bytes_received_;
}
inline void ChunkDiskStat::set_write_bytes_received(::google::protobuf::uint64 value) {
  set_has_write_bytes_received();
  write_bytes_received_ = value;
}

// optional uint64 write_bytes_received_interval = 19;
inline bool ChunkDiskStat::has_write_bytes_received_interval() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ChunkDiskStat::set_has_write_bytes_received_interval() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ChunkDiskStat::clear_has_write_bytes_received_interval() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ChunkDiskStat::clear_write_bytes_received_interval() {
  write_bytes_received_interval_ = GOOGLE_ULONGLONG(0);
  clear_has_write_bytes_received_interval();
}
inline ::google::protobuf::uint64 ChunkDiskStat::write_bytes_received_interval() const {
  return write_bytes_received_interval_;
}
inline void ChunkDiskStat::set_write_bytes_received_interval(::google::protobuf::uint64 value) {
  set_has_write_bytes_received_interval();
  write_bytes_received_interval_ = value;
}

// optional uint64 write_bytes_redirected = 20;
inline bool ChunkDiskStat::has_write_bytes_redirected() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ChunkDiskStat::set_has_write_bytes_redirected() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ChunkDiskStat::clear_has_write_bytes_redirected() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ChunkDiskStat::clear_write_bytes_redirected() {
  write_bytes_redirected_ = GOOGLE_ULONGLONG(0);
  clear_has_write_bytes_redirected();
}
inline ::google::protobuf::uint64 ChunkDiskStat::write_bytes_redirected() const {
  return write_bytes_redirected_;
}
inline void ChunkDiskStat::set_write_bytes_redirected(::google::protobuf::uint64 value) {
  set_has_write_bytes_redirected();
  write_bytes_redirected_ = value;
}

// optional uint64 flush_pending_queue_depth = 21;
inline bool ChunkDiskStat::has_flush_pending_queue_depth() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ChunkDiskStat::set_has_flush_pending_queue_depth() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ChunkDiskStat::clear_has_flush_pending_queue_depth() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ChunkDiskStat::clear_flush_pending_queue_depth() {
  flush_pending_queue_depth_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_pending_queue_depth();
}
inline ::google::protobuf::uint64 ChunkDiskStat::flush_pending_queue_depth() const {
  return flush_pending_queue_depth_;
}
inline void ChunkDiskStat::set_flush_pending_queue_depth(::google::protobuf::uint64 value) {
  set_has_flush_pending_queue_depth();
  flush_pending_queue_depth_ = value;
}

// optional uint64 flush_queue_depth = 22;
inline bool ChunkDiskStat::has_flush_queue_depth() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ChunkDiskStat::set_has_flush_queue_depth() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ChunkDiskStat::clear_has_flush_queue_depth() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ChunkDiskStat::clear_flush_queue_depth() {
  flush_queue_depth_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_queue_depth();
}
inline ::google::protobuf::uint64 ChunkDiskStat::flush_queue_depth() const {
  return flush_queue_depth_;
}
inline void ChunkDiskStat::set_flush_queue_depth(::google::protobuf::uint64 value) {
  set_has_flush_queue_depth();
  flush_queue_depth_ = value;
}

// optional uint64 pending_chunk_file_writers = 23;
inline bool ChunkDiskStat::has_pending_chunk_file_writers() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ChunkDiskStat::set_has_pending_chunk_file_writers() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ChunkDiskStat::clear_has_pending_chunk_file_writers() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ChunkDiskStat::clear_pending_chunk_file_writers() {
  pending_chunk_file_writers_ = GOOGLE_ULONGLONG(0);
  clear_has_pending_chunk_file_writers();
}
inline ::google::protobuf::uint64 ChunkDiskStat::pending_chunk_file_writers() const {
  return pending_chunk_file_writers_;
}
inline void ChunkDiskStat::set_pending_chunk_file_writers(::google::protobuf::uint64 value) {
  set_has_pending_chunk_file_writers();
  pending_chunk_file_writers_ = value;
}

// optional uint32 num_disk_repair_read = 24;
inline bool ChunkDiskStat::has_num_disk_repair_read() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ChunkDiskStat::set_has_num_disk_repair_read() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ChunkDiskStat::clear_has_num_disk_repair_read() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ChunkDiskStat::clear_num_disk_repair_read() {
  num_disk_repair_read_ = 0u;
  clear_has_num_disk_repair_read();
}
inline ::google::protobuf::uint32 ChunkDiskStat::num_disk_repair_read() const {
  return num_disk_repair_read_;
}
inline void ChunkDiskStat::set_num_disk_repair_read(::google::protobuf::uint32 value) {
  set_has_num_disk_repair_read();
  num_disk_repair_read_ = value;
}

// optional uint32 num_pending_write = 25;
inline bool ChunkDiskStat::has_num_pending_write() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ChunkDiskStat::set_has_num_pending_write() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ChunkDiskStat::clear_has_num_pending_write() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ChunkDiskStat::clear_num_pending_write() {
  num_pending_write_ = 0u;
  clear_has_num_pending_write();
}
inline ::google::protobuf::uint32 ChunkDiskStat::num_pending_write() const {
  return num_pending_write_;
}
inline void ChunkDiskStat::set_num_pending_write(::google::protobuf::uint32 value) {
  set_has_num_pending_write();
  num_pending_write_ = value;
}

// -------------------------------------------------------------------

// ChunkServerStat

// required .ChunkServerStat.ServerStatus status = 1;
inline bool ChunkServerStat::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChunkServerStat::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChunkServerStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChunkServerStat::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::ChunkServerStat_ServerStatus ChunkServerStat::status() const {
  return static_cast< ::ChunkServerStat_ServerStatus >(status_);
}
inline void ChunkServerStat::set_status(::ChunkServerStat_ServerStatus value) {
  GOOGLE_DCHECK(::ChunkServerStat_ServerStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required uint32 cs_id = 2;
inline bool ChunkServerStat::has_cs_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChunkServerStat::set_has_cs_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChunkServerStat::clear_has_cs_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChunkServerStat::clear_cs_id() {
  cs_id_ = 0u;
  clear_has_cs_id();
}
inline ::google::protobuf::uint32 ChunkServerStat::cs_id() const {
  return cs_id_;
}
inline void ChunkServerStat::set_cs_id(::google::protobuf::uint32 value) {
  set_has_cs_id();
  cs_id_ = value;
}

// required bytes cs_uuid = 3;
inline bool ChunkServerStat::has_cs_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChunkServerStat::set_has_cs_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChunkServerStat::clear_has_cs_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChunkServerStat::clear_cs_uuid() {
  if (cs_uuid_ != &::google::protobuf::internal::kEmptyString) {
    cs_uuid_->clear();
  }
  clear_has_cs_uuid();
}
inline const ::std::string& ChunkServerStat::cs_uuid() const {
  return *cs_uuid_;
}
inline void ChunkServerStat::set_cs_uuid(const ::std::string& value) {
  set_has_cs_uuid();
  if (cs_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cs_uuid_ = new ::std::string;
  }
  cs_uuid_->assign(value);
}
inline void ChunkServerStat::set_cs_uuid(const char* value) {
  set_has_cs_uuid();
  if (cs_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cs_uuid_ = new ::std::string;
  }
  cs_uuid_->assign(value);
}
inline void ChunkServerStat::set_cs_uuid(const void* value, size_t size) {
  set_has_cs_uuid();
  if (cs_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cs_uuid_ = new ::std::string;
  }
  cs_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerStat::mutable_cs_uuid() {
  set_has_cs_uuid();
  if (cs_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cs_uuid_ = new ::std::string;
  }
  return cs_uuid_;
}
inline ::std::string* ChunkServerStat::release_cs_uuid() {
  clear_has_cs_uuid();
  if (cs_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cs_uuid_;
    cs_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ChunkDiskStat stat = 4;
inline int ChunkServerStat::stat_size() const {
  return stat_.size();
}
inline void ChunkServerStat::clear_stat() {
  stat_.Clear();
}
inline const ::ChunkDiskStat& ChunkServerStat::stat(int index) const {
  return stat_.Get(index);
}
inline ::ChunkDiskStat* ChunkServerStat::mutable_stat(int index) {
  return stat_.Mutable(index);
}
inline ::ChunkDiskStat* ChunkServerStat::add_stat() {
  return stat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ChunkDiskStat >&
ChunkServerStat::stat() const {
  return stat_;
}
inline ::google::protobuf::RepeatedPtrField< ::ChunkDiskStat >*
ChunkServerStat::mutable_stat() {
  return &stat_;
}

// optional int64 total_bytes = 5;
inline bool ChunkServerStat::has_total_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChunkServerStat::set_has_total_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChunkServerStat::clear_has_total_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChunkServerStat::clear_total_bytes() {
  total_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_total_bytes();
}
inline ::google::protobuf::int64 ChunkServerStat::total_bytes() const {
  return total_bytes_;
}
inline void ChunkServerStat::set_total_bytes(::google::protobuf::int64 value) {
  set_has_total_bytes();
  total_bytes_ = value;
}

// optional int64 free_bytes = 6;
inline bool ChunkServerStat::has_free_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChunkServerStat::set_has_free_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChunkServerStat::clear_has_free_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChunkServerStat::clear_free_bytes() {
  free_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_free_bytes();
}
inline ::google::protobuf::int64 ChunkServerStat::free_bytes() const {
  return free_bytes_;
}
inline void ChunkServerStat::set_free_bytes(::google::protobuf::int64 value) {
  set_has_free_bytes();
  free_bytes_ = value;
}

// optional .MetaDiskStat chunk_meta_disk = 7;
inline bool ChunkServerStat::has_chunk_meta_disk() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChunkServerStat::set_has_chunk_meta_disk() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChunkServerStat::clear_has_chunk_meta_disk() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChunkServerStat::clear_chunk_meta_disk() {
  if (chunk_meta_disk_ != NULL) chunk_meta_disk_->::MetaDiskStat::Clear();
  clear_has_chunk_meta_disk();
}
inline const ::MetaDiskStat& ChunkServerStat::chunk_meta_disk() const {
  return chunk_meta_disk_ != NULL ? *chunk_meta_disk_ : *default_instance_->chunk_meta_disk_;
}
inline ::MetaDiskStat* ChunkServerStat::mutable_chunk_meta_disk() {
  set_has_chunk_meta_disk();
  if (chunk_meta_disk_ == NULL) chunk_meta_disk_ = new ::MetaDiskStat;
  return chunk_meta_disk_;
}
inline ::MetaDiskStat* ChunkServerStat::release_chunk_meta_disk() {
  clear_has_chunk_meta_disk();
  ::MetaDiskStat* temp = chunk_meta_disk_;
  chunk_meta_disk_ = NULL;
  return temp;
}

// optional uint64 update_timestamp = 8;
inline bool ChunkServerStat::has_update_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChunkServerStat::set_has_update_timestamp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChunkServerStat::clear_has_update_timestamp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChunkServerStat::clear_update_timestamp() {
  update_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_update_timestamp();
}
inline ::google::protobuf::uint64 ChunkServerStat::update_timestamp() const {
  return update_timestamp_;
}
inline void ChunkServerStat::set_update_timestamp(::google::protobuf::uint64 value) {
  set_has_update_timestamp();
  update_timestamp_ = value;
}

// optional bytes zone = 9;
inline bool ChunkServerStat::has_zone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChunkServerStat::set_has_zone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChunkServerStat::clear_has_zone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChunkServerStat::clear_zone() {
  if (zone_ != &::google::protobuf::internal::kEmptyString) {
    zone_->clear();
  }
  clear_has_zone();
}
inline const ::std::string& ChunkServerStat::zone() const {
  return *zone_;
}
inline void ChunkServerStat::set_zone(const ::std::string& value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
}
inline void ChunkServerStat::set_zone(const char* value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
}
inline void ChunkServerStat::set_zone(const void* value, size_t size) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerStat::mutable_zone() {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  return zone_;
}
inline ::std::string* ChunkServerStat::release_zone() {
  clear_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_;
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes machine_id = 10;
inline bool ChunkServerStat::has_machine_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ChunkServerStat::set_has_machine_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ChunkServerStat::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ChunkServerStat::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ChunkServerStat::machine_id() const {
  return *machine_id_;
}
inline void ChunkServerStat::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ChunkServerStat::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ChunkServerStat::set_machine_id(const void* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerStat::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ChunkServerStat::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes internal_cluster_uuid = 11;
inline bool ChunkServerStat::has_internal_cluster_uuid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ChunkServerStat::set_has_internal_cluster_uuid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ChunkServerStat::clear_has_internal_cluster_uuid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ChunkServerStat::clear_internal_cluster_uuid() {
  if (internal_cluster_uuid_ != &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_->clear();
  }
  clear_has_internal_cluster_uuid();
}
inline const ::std::string& ChunkServerStat::internal_cluster_uuid() const {
  return *internal_cluster_uuid_;
}
inline void ChunkServerStat::set_internal_cluster_uuid(const ::std::string& value) {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  internal_cluster_uuid_->assign(value);
}
inline void ChunkServerStat::set_internal_cluster_uuid(const char* value) {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  internal_cluster_uuid_->assign(value);
}
inline void ChunkServerStat::set_internal_cluster_uuid(const void* value, size_t size) {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  internal_cluster_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerStat::mutable_internal_cluster_uuid() {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  return internal_cluster_uuid_;
}
inline ::std::string* ChunkServerStat::release_internal_cluster_uuid() {
  clear_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internal_cluster_uuid_;
    internal_cluster_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes version = 12;
inline bool ChunkServerStat::has_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ChunkServerStat::set_has_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ChunkServerStat::clear_has_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ChunkServerStat::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ChunkServerStat::version() const {
  return *version_;
}
inline void ChunkServerStat::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChunkServerStat::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChunkServerStat::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerStat::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ChunkServerStat::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 total_repair_read = 13;
inline bool ChunkServerStat::has_total_repair_read() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ChunkServerStat::set_has_total_repair_read() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ChunkServerStat::clear_has_total_repair_read() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ChunkServerStat::clear_total_repair_read() {
  total_repair_read_ = 0u;
  clear_has_total_repair_read();
}
inline ::google::protobuf::uint32 ChunkServerStat::total_repair_read() const {
  return total_repair_read_;
}
inline void ChunkServerStat::set_total_repair_read(::google::protobuf::uint32 value) {
  set_has_total_repair_read();
  total_repair_read_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChunkDiskStat_DiskStatus>() {
  return ::ChunkDiskStat_DiskStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChunkServerStat_ServerStatus>() {
  return ::ChunkServerStat_ServerStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cdb_5fcommon_2eproto__INCLUDED
