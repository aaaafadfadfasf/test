/*  Cluster setup workflow:
 *  (1)Meta:
 *    Format metadb disk. FormatMetaDbDisk.
 *    Define MetaServerConf for each meta node.
 *    call SerializeMetaServerConf to serialize MetaServerConf to one config file
 *    config file path will be used as flag to start meta node.
 *  (3)Chunk:
 *    Format chunkdb disk. FormatChunkDbDisk.
 *    Define ChunkServerConf for each chunk node.
 *    call SerializeChunkServerConf to serialize ChunkServerConf to one config file
 *    config file path will be used as flag to start chunk node.
 *
 *    Format raw data disk. chunk_admin_client_->FormatChunkDisk
 *    chunk_admin_client_->StartChunkDisk(raw disk name);
 *
 * Cluster meta recovery workflow:
 *  (1) Stop all meta nodes.
 *  (2) Format meta disks.
 *  (3) Start meta clusters. Make sure all chunk servers are running.
 *  (4) Call meta master. RecoverMeta(internal_cluster_uuid, machine ids for chunk servers).
 */
#ifndef ADMIN_CLIENT_H_
#define ADMIN_CLIENT_H_

#include "misc.h"
#include "status.h"
#include "cdb_admin.pb.h"

namespace cdb_admin {

class MetaAdminClient {
  public:
    MetaAdminClient() {
    }

    virtual ~MetaAdminClient() {
    }

    virtual AdminStatus Stat(MetaStat* stat) = 0;

    virtual AdminStatus BackupMeta(const std::string& file_path,
                                   uint32 timeout_secs) = 0;

    // internal_cluster_uuid is generated by cdb master, can be retrieved from MetaStat.
    // when internal_cluster_uuid is set, used for meta disk recovery.
    virtual AdminStatus RecoverMeta(
        const std::string& internal_cluster_uuid,
        const std::vector<std::string>& chunk_machine_ids) = 0;

    virtual AdminStatus Rebalance(const std::string& zone_name) = 0;

    virtual void Stop() = 0;

  private:
    DISALLOW_COPY_AND_ASSIGN(MetaAdminClient);
};

class ChunkAdminClient {
  public:
    ChunkAdminClient() {
    }

    virtual ~ChunkAdminClient() {
    }

    // Disk management
    virtual AdminStatus FormatChunkDisk(const FormatDiskReq& user_req) = 0;

    // Set timeout_ms = 60000(1 minute) or larger as chunk disk need load buffered data.
    // Return Status: OK, TIMEOUT
    virtual AdminStatus StartChunkDisk(const std::string& disk_uuid,
                                       const std::string& chunk_disk,
                                       uint32 timeout_ms) = 0;

    // Set timeout_ms = 60000(1 minute) or larger as chunk disk need finish pending io.
    virtual AdminStatus StopChunkDisk(const std::string& disk_uuid,
                                      uint32 timeout_ms, bool need_recovery =
                                          false) = 0;

    // IP management
    virtual AdminStatus DisableIp(const std::string& ip) = 0;
    virtual AdminStatus EnableIp(const std::string& ip) = 0;

    // Stat
    virtual AdminStatus Stat(ChunkServerStat* stat) = 0;

    // When power_off = true, flush buffered data only and exit process.
    // When power_off = false, return false if chunk server has unmounted disk.
    virtual bool Stop(bool power_off) = 0;

  private:
    DISALLOW_COPY_AND_ASSIGN(ChunkAdminClient);
};

enum DiskType {
  DISK_TYPE_META = 1, DISK_TYPE_CHUNK_META, DISK_TYPE_CHUNK_DATA
};

bool DiskFormatted(const std::string& disk_uuid, const std::string& disk_name,
                   DiskType* disk_type, std::string* error_msg);
void PrintSuperBlock(const std::string& disk_name);

// return NULL if failed to connect to meta_server.
MetaAdminClient* CreateMetaAdminClient(uint32 meta_port, uint32 timeout_secs);

// return NULL if failed to connect to chunk_server.
ChunkAdminClient* CreateChunkAdminClient(uint32 chunk_port,
                                         uint32 timeout_secs);

AdminStatus FormatMetaDbDisk(const FormatDiskReq& user_req);
AdminStatus FormatChunkDbDisk(const FormatDiskReq& user_req);

// destroy data but keeping its superblock. Used when chunk/meta data is corrupted.
AdminStatus DestroyData(const std::string& disk_name);

void SerilizeMetaCluster(const MetaCluster& cluster,
                         const std::string& config_file_path);

void SerializeMetaServerConf(const MetaServerConf& conf,
                             const std::string& config_file_path);

void SerializeChunkServerConf(const ChunkServerConf& conf,
                              const std::string& config_file_path);

void ParseMetaCluster(const std::string& config_file_path,
                      MetaCluster* cluster);

void ParseMetaServerConf(const std::string& config_file_path,
                         MetaServerConf* conf);

void ParseChunkServerConf(const std::string& config_file_path,
                          ChunkServerConf* conf);

AdminStatus StopAndBackupMetaLog(uint32 meta_port,
                                 const std::string& ram_home_dir,
                                 const std::string& backup_home_dir,
                                 uint32 timeout_seconds, bool bbu_power_off);

// when bbu_power_off, won't flush hard disks buffer.
AdminStatus StopAndBackupChunkLog(uint32 chunk_port,
                                  const std::string& ram_home_dir,
                                  const std::string& backup_home_dir,
                                  uint32 timeout_seconds, bool bbu_power_off);

} /* namespace cdb_admin */
#endif /* ADMIN_CLIENT_H_ */
