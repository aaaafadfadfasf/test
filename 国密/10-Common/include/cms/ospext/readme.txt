//描述该目录下的详细情况

该目录下存放的是 ospext，该库封装了 事务模式 ，其历史演化过程如下：
1，在cusdk中实现了原始的事务模式，每个事务都是一个CTask的子类，事务类实现了CTask的一些虚方法
上层在收到消息时，根据TaskID找到对应的事务类，并将消息丢给事务类处理

事务类中真正干活的是里面的CState的子类，状态类也实现了CState的一些虚方法
收到消息触发状态类后，由状态类实现业务逻辑，然后切换下一状态类，等待新的消息触发

另外还实现了事务管理以及事务超时
TaskManager登记每个事务类，记录在其内的CXMap<TaskID, PCTask>中
专门有一个OspApp对调用TaskManager的TimePoll方法，该方法会轮询每一个登记在册的事务类
对其引用计数自增，然后调用事务类的TimePoll方法，由每个状态类判断当前状态是否超时

所有的函数调用都是利用CTask的多态来完成，最上层的业务OspApp不感知具体的事务类，以及内部的状态类
原始实现参考cusdk工程

2，ospext在cusdk的模型基础上，对osp进行了封装
2.1，完善了原先的CTask的相关模型，使得各接口更加易用，数据关系联系更加紧密
2.2，TaskManager封装在了OspAppExt内，用户不再关心
2.3，OspAppExt增加一些对CTask的管理

                                                             2011.10.12 by liangli
-------------------------------------------------------------------------------------
但是在实践中发现以上事务模型存在一些问题
1，编码复杂，容易产生类的大爆炸。即使一个很小的功能，也需要定义一个CTask和至少一个CState
这些代码在产生过程中有很多冗余但是不得不做的工作

2，后续维护者理解困难
面对这么多CState，要把每一个看完并理解其中的关系，比较耗时

3，容易出错
在CState中作NextState切换时，内部实现是先将当前CState先delete掉，然后new CNewState替换当前指针
程序员很容易在NextState后继续使用当前的CState，导致崩溃，问题很难定位

同时这么多的class都需要new和delete，经常有程序员delete this，导致释放了错误的对象

张应能提出了一种新的状态机模型，给大家提供了一种新的思路
新模型中用状态枚举和函数取代了CState，两种方式等价，但是避免了new和delete操作

由梁黎和范小钢改造现有的OspExt库，去掉CState类，改为状态机方式
其他流程都不变，只是在CTask中增加一个状态函数登记表，将每种状态枚举下需要调用那种函数登记下来
切换状态时只改变状态枚举值即可
                                                             2011.10.12 by liangli
-------------------------------------------------------------------------------------
