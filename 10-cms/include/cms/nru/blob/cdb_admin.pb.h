// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cdb_admin.proto

#ifndef PROTOBUF_cdb_5fadmin_2eproto__INCLUDED
#define PROTOBUF_cdb_5fadmin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "cdb_common.pb.h"
// @@protoc_insertion_point(includes)

namespace cdb_admin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cdb_5fadmin_2eproto();
void protobuf_AssignDesc_cdb_5fadmin_2eproto();
void protobuf_ShutdownFile_cdb_5fadmin_2eproto();

class AdminStatus;
class FormatDiskReq;
class MetaNode;
class MetaCluster;
class MetaServerConf;
class ChunkServerConf;
class StatMetaReq;
class MetaStat;
class AdminReq;
class AdminLoginReq;

enum AdminStatus_ReturnCode {
  AdminStatus_ReturnCode_OK = 1,
  AdminStatus_ReturnCode_TIME_OUT = 2,
  AdminStatus_ReturnCode_FAILED_TO_CONNECT = 3,
  AdminStatus_ReturnCode_FAILED_OPEN_DISK = 4,
  AdminStatus_ReturnCode_DISK_TOO_SMALL = 5,
  AdminStatus_ReturnCode_DISK_NOT_BELONGING_TO_CLUSTER = 6,
  AdminStatus_ReturnCode_DISK_FORMATTED = 101,
  AdminStatus_ReturnCode_DISK_EXISTING_IN_CLUSTER = 102,
  AdminStatus_ReturnCode_DISK_NOT_FORMATTED = 201,
  AdminStatus_ReturnCode_DISK_NOT_BELONGING_TO_CHUNK_SERVER = 202,
  AdminStatus_ReturnCode_DISK_CORRUPTED = 203,
  AdminStatus_ReturnCode_HAVE_DISK_RUNNING = 801,
  AdminStatus_ReturnCode_INVALID_ARGUMENT = 901
};
bool AdminStatus_ReturnCode_IsValid(int value);
const AdminStatus_ReturnCode AdminStatus_ReturnCode_ReturnCode_MIN = AdminStatus_ReturnCode_OK;
const AdminStatus_ReturnCode AdminStatus_ReturnCode_ReturnCode_MAX = AdminStatus_ReturnCode_INVALID_ARGUMENT;
const int AdminStatus_ReturnCode_ReturnCode_ARRAYSIZE = AdminStatus_ReturnCode_ReturnCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdminStatus_ReturnCode_descriptor();
inline const ::std::string& AdminStatus_ReturnCode_Name(AdminStatus_ReturnCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdminStatus_ReturnCode_descriptor(), value);
}
inline bool AdminStatus_ReturnCode_Parse(
    const ::std::string& name, AdminStatus_ReturnCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdminStatus_ReturnCode>(
    AdminStatus_ReturnCode_descriptor(), name, value);
}
enum MetaState {
  SLAVE = 1,
  MASTER_CANDIDATE = 2,
  MASTER = 3
};
bool MetaState_IsValid(int value);
const MetaState MetaState_MIN = SLAVE;
const MetaState MetaState_MAX = MASTER;
const int MetaState_ARRAYSIZE = MetaState_MAX + 1;

const ::google::protobuf::EnumDescriptor* MetaState_descriptor();
inline const ::std::string& MetaState_Name(MetaState value) {
  return ::google::protobuf::internal::NameOfEnum(
    MetaState_descriptor(), value);
}
inline bool MetaState_Parse(
    const ::std::string& name, MetaState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MetaState>(
    MetaState_descriptor(), name, value);
}
// ===================================================================

class AdminStatus : public ::google::protobuf::Message {
 public:
  AdminStatus();
  virtual ~AdminStatus();
  
  AdminStatus(const AdminStatus& from);
  
  inline AdminStatus& operator=(const AdminStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminStatus& default_instance();
  
  void Swap(AdminStatus* other);
  
  // implements Message ----------------------------------------------
  
  AdminStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminStatus& from);
  void MergeFrom(const AdminStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef AdminStatus_ReturnCode ReturnCode;
  static const ReturnCode OK = AdminStatus_ReturnCode_OK;
  static const ReturnCode TIME_OUT = AdminStatus_ReturnCode_TIME_OUT;
  static const ReturnCode FAILED_TO_CONNECT = AdminStatus_ReturnCode_FAILED_TO_CONNECT;
  static const ReturnCode FAILED_OPEN_DISK = AdminStatus_ReturnCode_FAILED_OPEN_DISK;
  static const ReturnCode DISK_TOO_SMALL = AdminStatus_ReturnCode_DISK_TOO_SMALL;
  static const ReturnCode DISK_NOT_BELONGING_TO_CLUSTER = AdminStatus_ReturnCode_DISK_NOT_BELONGING_TO_CLUSTER;
  static const ReturnCode DISK_FORMATTED = AdminStatus_ReturnCode_DISK_FORMATTED;
  static const ReturnCode DISK_EXISTING_IN_CLUSTER = AdminStatus_ReturnCode_DISK_EXISTING_IN_CLUSTER;
  static const ReturnCode DISK_NOT_FORMATTED = AdminStatus_ReturnCode_DISK_NOT_FORMATTED;
  static const ReturnCode DISK_NOT_BELONGING_TO_CHUNK_SERVER = AdminStatus_ReturnCode_DISK_NOT_BELONGING_TO_CHUNK_SERVER;
  static const ReturnCode DISK_CORRUPTED = AdminStatus_ReturnCode_DISK_CORRUPTED;
  static const ReturnCode HAVE_DISK_RUNNING = AdminStatus_ReturnCode_HAVE_DISK_RUNNING;
  static const ReturnCode INVALID_ARGUMENT = AdminStatus_ReturnCode_INVALID_ARGUMENT;
  static inline bool ReturnCode_IsValid(int value) {
    return AdminStatus_ReturnCode_IsValid(value);
  }
  static const ReturnCode ReturnCode_MIN =
    AdminStatus_ReturnCode_ReturnCode_MIN;
  static const ReturnCode ReturnCode_MAX =
    AdminStatus_ReturnCode_ReturnCode_MAX;
  static const int ReturnCode_ARRAYSIZE =
    AdminStatus_ReturnCode_ReturnCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReturnCode_descriptor() {
    return AdminStatus_ReturnCode_descriptor();
  }
  static inline const ::std::string& ReturnCode_Name(ReturnCode value) {
    return AdminStatus_ReturnCode_Name(value);
  }
  static inline bool ReturnCode_Parse(const ::std::string& name,
      ReturnCode* value) {
    return AdminStatus_ReturnCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .cdb_admin.AdminStatus.ReturnCode code = 1 [default = OK];
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::cdb_admin::AdminStatus_ReturnCode code() const;
  inline void set_code(::cdb_admin::AdminStatus_ReturnCode value);
  
  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.AdminStatus)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* error_;
  int code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static AdminStatus* default_instance_;
};
// -------------------------------------------------------------------

class FormatDiskReq : public ::google::protobuf::Message {
 public:
  FormatDiskReq();
  virtual ~FormatDiskReq();
  
  FormatDiskReq(const FormatDiskReq& from);
  
  inline FormatDiskReq& operator=(const FormatDiskReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatDiskReq& default_instance();
  
  void Swap(FormatDiskReq* other);
  
  // implements Message ----------------------------------------------
  
  FormatDiskReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormatDiskReq& from);
  void MergeFrom(const FormatDiskReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cluster_name = 1;
  inline bool has_cluster_name() const;
  inline void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  inline const ::std::string& cluster_name() const;
  inline void set_cluster_name(const ::std::string& value);
  inline void set_cluster_name(const char* value);
  inline void set_cluster_name(const char* value, size_t size);
  inline ::std::string* mutable_cluster_name();
  inline ::std::string* release_cluster_name();
  
  // required bytes cluster_uuid = 2;
  inline bool has_cluster_uuid() const;
  inline void clear_cluster_uuid();
  static const int kClusterUuidFieldNumber = 2;
  inline const ::std::string& cluster_uuid() const;
  inline void set_cluster_uuid(const ::std::string& value);
  inline void set_cluster_uuid(const char* value);
  inline void set_cluster_uuid(const void* value, size_t size);
  inline ::std::string* mutable_cluster_uuid();
  inline ::std::string* release_cluster_uuid();
  
  // required string disk_uuid = 3;
  inline bool has_disk_uuid() const;
  inline void clear_disk_uuid();
  static const int kDiskUuidFieldNumber = 3;
  inline const ::std::string& disk_uuid() const;
  inline void set_disk_uuid(const ::std::string& value);
  inline void set_disk_uuid(const char* value);
  inline void set_disk_uuid(const char* value, size_t size);
  inline ::std::string* mutable_disk_uuid();
  inline ::std::string* release_disk_uuid();
  
  // required string disk_name = 4;
  inline bool has_disk_name() const;
  inline void clear_disk_name();
  static const int kDiskNameFieldNumber = 4;
  inline const ::std::string& disk_name() const;
  inline void set_disk_name(const ::std::string& value);
  inline void set_disk_name(const char* value);
  inline void set_disk_name(const char* value, size_t size);
  inline ::std::string* mutable_disk_name();
  inline ::std::string* release_disk_name();
  
  // required bool force_format = 5 [default = false];
  inline bool has_force_format() const;
  inline void clear_force_format();
  static const int kForceFormatFieldNumber = 5;
  inline bool force_format() const;
  inline void set_force_format(bool value);
  
  // @@protoc_insertion_point(class_scope:cdb_admin.FormatDiskReq)
 private:
  inline void set_has_cluster_name();
  inline void clear_has_cluster_name();
  inline void set_has_cluster_uuid();
  inline void clear_has_cluster_uuid();
  inline void set_has_disk_uuid();
  inline void clear_has_disk_uuid();
  inline void set_has_disk_name();
  inline void clear_has_disk_name();
  inline void set_has_force_format();
  inline void clear_has_force_format();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cluster_name_;
  ::std::string* cluster_uuid_;
  ::std::string* disk_uuid_;
  ::std::string* disk_name_;
  bool force_format_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static FormatDiskReq* default_instance_;
};
// -------------------------------------------------------------------

class MetaNode : public ::google::protobuf::Message {
 public:
  MetaNode();
  virtual ~MetaNode();
  
  MetaNode(const MetaNode& from);
  
  inline MetaNode& operator=(const MetaNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaNode& default_instance();
  
  void Swap(MetaNode* other);
  
  // implements Message ----------------------------------------------
  
  MetaNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaNode& from);
  void MergeFrom(const MetaNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 meta_port = 2;
  inline bool has_meta_port() const;
  inline void clear_meta_port();
  static const int kMetaPortFieldNumber = 2;
  inline ::google::protobuf::uint32 meta_port() const;
  inline void set_meta_port(::google::protobuf::uint32 value);
  
  // required uint32 election_port = 3;
  inline bool has_election_port() const;
  inline void clear_election_port();
  static const int kElectionPortFieldNumber = 3;
  inline ::google::protobuf::uint32 election_port() const;
  inline void set_election_port(::google::protobuf::uint32 value);
  
  // required string primary_ip = 4;
  inline bool has_primary_ip() const;
  inline void clear_primary_ip();
  static const int kPrimaryIpFieldNumber = 4;
  inline const ::std::string& primary_ip() const;
  inline void set_primary_ip(const ::std::string& value);
  inline void set_primary_ip(const char* value);
  inline void set_primary_ip(const char* value, size_t size);
  inline ::std::string* mutable_primary_ip();
  inline ::std::string* release_primary_ip();
  
  // optional string secondary_ip = 5;
  inline bool has_secondary_ip() const;
  inline void clear_secondary_ip();
  static const int kSecondaryIpFieldNumber = 5;
  inline const ::std::string& secondary_ip() const;
  inline void set_secondary_ip(const ::std::string& value);
  inline void set_secondary_ip(const char* value);
  inline void set_secondary_ip(const char* value, size_t size);
  inline ::std::string* mutable_secondary_ip();
  inline ::std::string* release_secondary_ip();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.MetaNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_meta_port();
  inline void clear_has_meta_port();
  inline void set_has_election_port();
  inline void clear_has_election_port();
  inline void set_has_primary_ip();
  inline void clear_has_primary_ip();
  inline void set_has_secondary_ip();
  inline void clear_has_secondary_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 meta_port_;
  ::std::string* primary_ip_;
  ::std::string* secondary_ip_;
  ::google::protobuf::uint32 election_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static MetaNode* default_instance_;
};
// -------------------------------------------------------------------

class MetaCluster : public ::google::protobuf::Message {
 public:
  MetaCluster();
  virtual ~MetaCluster();
  
  MetaCluster(const MetaCluster& from);
  
  inline MetaCluster& operator=(const MetaCluster& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaCluster& default_instance();
  
  void Swap(MetaCluster* other);
  
  // implements Message ----------------------------------------------
  
  MetaCluster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaCluster& from);
  void MergeFrom(const MetaCluster& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cluster_name = 1;
  inline bool has_cluster_name() const;
  inline void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  inline const ::std::string& cluster_name() const;
  inline void set_cluster_name(const ::std::string& value);
  inline void set_cluster_name(const char* value);
  inline void set_cluster_name(const char* value, size_t size);
  inline ::std::string* mutable_cluster_name();
  inline ::std::string* release_cluster_name();
  
  // required bytes cluster_uuid = 2;
  inline bool has_cluster_uuid() const;
  inline void clear_cluster_uuid();
  static const int kClusterUuidFieldNumber = 2;
  inline const ::std::string& cluster_uuid() const;
  inline void set_cluster_uuid(const ::std::string& value);
  inline void set_cluster_uuid(const char* value);
  inline void set_cluster_uuid(const void* value, size_t size);
  inline ::std::string* mutable_cluster_uuid();
  inline ::std::string* release_cluster_uuid();
  
  // required uint32 meta_service_port = 3;
  inline bool has_meta_service_port() const;
  inline void clear_meta_service_port();
  static const int kMetaServicePortFieldNumber = 3;
  inline ::google::protobuf::uint32 meta_service_port() const;
  inline void set_meta_service_port(::google::protobuf::uint32 value);
  
  // repeated .cdb_admin.MetaNode node = 4;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 4;
  inline const ::cdb_admin::MetaNode& node(int index) const;
  inline ::cdb_admin::MetaNode* mutable_node(int index);
  inline ::cdb_admin::MetaNode* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::cdb_admin::MetaNode >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::cdb_admin::MetaNode >*
      mutable_node();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.MetaCluster)
 private:
  inline void set_has_cluster_name();
  inline void clear_has_cluster_name();
  inline void set_has_cluster_uuid();
  inline void clear_has_cluster_uuid();
  inline void set_has_meta_service_port();
  inline void clear_has_meta_service_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cluster_name_;
  ::std::string* cluster_uuid_;
  ::google::protobuf::RepeatedPtrField< ::cdb_admin::MetaNode > node_;
  ::google::protobuf::uint32 meta_service_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static MetaCluster* default_instance_;
};
// -------------------------------------------------------------------

class MetaServerConf : public ::google::protobuf::Message {
 public:
  MetaServerConf();
  virtual ~MetaServerConf();
  
  MetaServerConf(const MetaServerConf& from);
  
  inline MetaServerConf& operator=(const MetaServerConf& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaServerConf& default_instance();
  
  void Swap(MetaServerConf* other);
  
  // implements Message ----------------------------------------------
  
  MetaServerConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaServerConf& from);
  void MergeFrom(const MetaServerConf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .cdb_admin.MetaCluster cluster = 1;
  inline bool has_cluster() const;
  inline void clear_cluster();
  static const int kClusterFieldNumber = 1;
  inline const ::cdb_admin::MetaCluster& cluster() const;
  inline ::cdb_admin::MetaCluster* mutable_cluster();
  inline ::cdb_admin::MetaCluster* release_cluster();
  
  // required uint32 my_id = 2;
  inline bool has_my_id() const;
  inline void clear_my_id();
  static const int kMyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 my_id() const;
  inline void set_my_id(::google::protobuf::uint32 value);
  
  // required string db_disk_name = 3;
  inline bool has_db_disk_name() const;
  inline void clear_db_disk_name();
  static const int kDbDiskNameFieldNumber = 3;
  inline const ::std::string& db_disk_name() const;
  inline void set_db_disk_name(const ::std::string& value);
  inline void set_db_disk_name(const char* value);
  inline void set_db_disk_name(const char* value, size_t size);
  inline ::std::string* mutable_db_disk_name();
  inline ::std::string* release_db_disk_name();
  
  // required string db_ram_cache_dir = 5;
  inline bool has_db_ram_cache_dir() const;
  inline void clear_db_ram_cache_dir();
  static const int kDbRamCacheDirFieldNumber = 5;
  inline const ::std::string& db_ram_cache_dir() const;
  inline void set_db_ram_cache_dir(const ::std::string& value);
  inline void set_db_ram_cache_dir(const char* value);
  inline void set_db_ram_cache_dir(const char* value, size_t size);
  inline ::std::string* mutable_db_ram_cache_dir();
  inline ::std::string* release_db_ram_cache_dir();
  
  // optional string local_backup_dir = 6;
  inline bool has_local_backup_dir() const;
  inline void clear_local_backup_dir();
  static const int kLocalBackupDirFieldNumber = 6;
  inline const ::std::string& local_backup_dir() const;
  inline void set_local_backup_dir(const ::std::string& value);
  inline void set_local_backup_dir(const char* value);
  inline void set_local_backup_dir(const char* value, size_t size);
  inline ::std::string* mutable_local_backup_dir();
  inline ::std::string* release_local_backup_dir();
  
  // optional bool has_bbu = 7;
  inline bool has_has_bbu() const;
  inline void clear_has_bbu();
  static const int kHasBbuFieldNumber = 7;
  inline bool has_bbu() const;
  inline void set_has_bbu(bool value);
  
  // @@protoc_insertion_point(class_scope:cdb_admin.MetaServerConf)
 private:
  inline void set_has_cluster();
  inline void clear_has_cluster();
  inline void set_has_my_id();
  inline void clear_has_my_id();
  inline void set_has_db_disk_name();
  inline void clear_has_db_disk_name();
  inline void set_has_db_ram_cache_dir();
  inline void clear_has_db_ram_cache_dir();
  inline void set_has_local_backup_dir();
  inline void clear_has_local_backup_dir();
  inline void set_has_has_bbu();
  inline void clear_has_has_bbu();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cdb_admin::MetaCluster* cluster_;
  ::std::string* db_disk_name_;
  ::std::string* db_ram_cache_dir_;
  ::google::protobuf::uint32 my_id_;
  bool has_bbu_;
  ::std::string* local_backup_dir_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static MetaServerConf* default_instance_;
};
// -------------------------------------------------------------------

class ChunkServerConf : public ::google::protobuf::Message {
 public:
  ChunkServerConf();
  virtual ~ChunkServerConf();
  
  ChunkServerConf(const ChunkServerConf& from);
  
  inline ChunkServerConf& operator=(const ChunkServerConf& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChunkServerConf& default_instance();
  
  void Swap(ChunkServerConf* other);
  
  // implements Message ----------------------------------------------
  
  ChunkServerConf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChunkServerConf& from);
  void MergeFrom(const ChunkServerConf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .cdb_admin.MetaCluster cluster = 1;
  inline bool has_cluster() const;
  inline void clear_cluster();
  static const int kClusterFieldNumber = 1;
  inline const ::cdb_admin::MetaCluster& cluster() const;
  inline ::cdb_admin::MetaCluster* mutable_cluster();
  inline ::cdb_admin::MetaCluster* release_cluster();
  
  // required uint32 chunk_port = 2;
  inline bool has_chunk_port() const;
  inline void clear_chunk_port();
  static const int kChunkPortFieldNumber = 2;
  inline ::google::protobuf::uint32 chunk_port() const;
  inline void set_chunk_port(::google::protobuf::uint32 value);
  
  // repeated string chunk_ips = 3;
  inline int chunk_ips_size() const;
  inline void clear_chunk_ips();
  static const int kChunkIpsFieldNumber = 3;
  inline const ::std::string& chunk_ips(int index) const;
  inline ::std::string* mutable_chunk_ips(int index);
  inline void set_chunk_ips(int index, const ::std::string& value);
  inline void set_chunk_ips(int index, const char* value);
  inline void set_chunk_ips(int index, const char* value, size_t size);
  inline ::std::string* add_chunk_ips();
  inline void add_chunk_ips(const ::std::string& value);
  inline void add_chunk_ips(const char* value);
  inline void add_chunk_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunk_ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunk_ips();
  
  // required string db_disk_name = 4;
  inline bool has_db_disk_name() const;
  inline void clear_db_disk_name();
  static const int kDbDiskNameFieldNumber = 4;
  inline const ::std::string& db_disk_name() const;
  inline void set_db_disk_name(const ::std::string& value);
  inline void set_db_disk_name(const char* value);
  inline void set_db_disk_name(const char* value, size_t size);
  inline ::std::string* mutable_db_disk_name();
  inline ::std::string* release_db_disk_name();
  
  // required string db_ram_cache_dir = 5;
  inline bool has_db_ram_cache_dir() const;
  inline void clear_db_ram_cache_dir();
  static const int kDbRamCacheDirFieldNumber = 5;
  inline const ::std::string& db_ram_cache_dir() const;
  inline void set_db_ram_cache_dir(const ::std::string& value);
  inline void set_db_ram_cache_dir(const char* value);
  inline void set_db_ram_cache_dir(const char* value, size_t size);
  inline ::std::string* mutable_db_ram_cache_dir();
  inline ::std::string* release_db_ram_cache_dir();
  
  // optional string local_backup_dir = 6;
  inline bool has_local_backup_dir() const;
  inline void clear_local_backup_dir();
  static const int kLocalBackupDirFieldNumber = 6;
  inline const ::std::string& local_backup_dir() const;
  inline void set_local_backup_dir(const ::std::string& value);
  inline void set_local_backup_dir(const char* value);
  inline void set_local_backup_dir(const char* value, size_t size);
  inline ::std::string* mutable_local_backup_dir();
  inline ::std::string* release_local_backup_dir();
  
  // optional bool has_bbu = 7;
  inline bool has_has_bbu() const;
  inline void clear_has_bbu();
  static const int kHasBbuFieldNumber = 7;
  inline bool has_bbu() const;
  inline void set_has_bbu(bool value);
  
  // optional string zone_name = 8;
  inline bool has_zone_name() const;
  inline void clear_zone_name();
  static const int kZoneNameFieldNumber = 8;
  inline const ::std::string& zone_name() const;
  inline void set_zone_name(const ::std::string& value);
  inline void set_zone_name(const char* value);
  inline void set_zone_name(const char* value, size_t size);
  inline ::std::string* mutable_zone_name();
  inline ::std::string* release_zone_name();
  
  // optional string machine_id = 9;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 9;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.ChunkServerConf)
 private:
  inline void set_has_cluster();
  inline void clear_has_cluster();
  inline void set_has_chunk_port();
  inline void clear_has_chunk_port();
  inline void set_has_db_disk_name();
  inline void clear_has_db_disk_name();
  inline void set_has_db_ram_cache_dir();
  inline void clear_has_db_ram_cache_dir();
  inline void set_has_local_backup_dir();
  inline void clear_has_local_backup_dir();
  inline void set_has_has_bbu();
  inline void clear_has_has_bbu();
  inline void set_has_zone_name();
  inline void clear_has_zone_name();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cdb_admin::MetaCluster* cluster_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunk_ips_;
  ::std::string* db_disk_name_;
  ::google::protobuf::uint32 chunk_port_;
  bool has_bbu_;
  ::std::string* db_ram_cache_dir_;
  ::std::string* local_backup_dir_;
  ::std::string* zone_name_;
  ::std::string* machine_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static ChunkServerConf* default_instance_;
};
// -------------------------------------------------------------------

class StatMetaReq : public ::google::protobuf::Message {
 public:
  StatMetaReq();
  virtual ~StatMetaReq();
  
  StatMetaReq(const StatMetaReq& from);
  
  inline StatMetaReq& operator=(const StatMetaReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatMetaReq& default_instance();
  
  void Swap(StatMetaReq* other);
  
  // implements Message ----------------------------------------------
  
  StatMetaReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatMetaReq& from);
  void MergeFrom(const StatMetaReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.StatMetaReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static StatMetaReq* default_instance_;
};
// -------------------------------------------------------------------

class MetaStat : public ::google::protobuf::Message {
 public:
  MetaStat();
  virtual ~MetaStat();
  
  MetaStat(const MetaStat& from);
  
  inline MetaStat& operator=(const MetaStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaStat& default_instance();
  
  void Swap(MetaStat* other);
  
  // implements Message ----------------------------------------------
  
  MetaStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaStat& from);
  void MergeFrom(const MetaStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .cdb_admin.MetaState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline cdb_admin::MetaState state() const;
  inline void set_state(cdb_admin::MetaState value);
  
  // optional uint32 leader_id = 2;
  inline bool has_leader_id() const;
  inline void clear_leader_id();
  static const int kLeaderIdFieldNumber = 2;
  inline ::google::protobuf::uint32 leader_id() const;
  inline void set_leader_id(::google::protobuf::uint32 value);
  
  // optional .MetaDiskStat meta_disk = 3;
  inline bool has_meta_disk() const;
  inline void clear_meta_disk();
  static const int kMetaDiskFieldNumber = 3;
  inline const ::MetaDiskStat& meta_disk() const;
  inline ::MetaDiskStat* mutable_meta_disk();
  inline ::MetaDiskStat* release_meta_disk();
  
  // optional bytes internal_cluster_uuid = 4;
  inline bool has_internal_cluster_uuid() const;
  inline void clear_internal_cluster_uuid();
  static const int kInternalClusterUuidFieldNumber = 4;
  inline const ::std::string& internal_cluster_uuid() const;
  inline void set_internal_cluster_uuid(const ::std::string& value);
  inline void set_internal_cluster_uuid(const char* value);
  inline void set_internal_cluster_uuid(const void* value, size_t size);
  inline ::std::string* mutable_internal_cluster_uuid();
  inline ::std::string* release_internal_cluster_uuid();
  
  // optional bytes version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.MetaStat)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_leader_id();
  inline void clear_has_leader_id();
  inline void set_has_meta_disk();
  inline void clear_has_meta_disk();
  inline void set_has_internal_cluster_uuid();
  inline void clear_has_internal_cluster_uuid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int state_;
  ::google::protobuf::uint32 leader_id_;
  ::MetaDiskStat* meta_disk_;
  ::std::string* internal_cluster_uuid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static MetaStat* default_instance_;
};
// -------------------------------------------------------------------

class AdminReq : public ::google::protobuf::Message {
 public:
  AdminReq();
  virtual ~AdminReq();
  
  AdminReq(const AdminReq& from);
  
  inline AdminReq& operator=(const AdminReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminReq& default_instance();
  
  void Swap(AdminReq* other);
  
  // implements Message ----------------------------------------------
  
  AdminReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminReq& from);
  void MergeFrom(const AdminReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool stop = 1;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 1;
  inline bool stop() const;
  inline void set_stop(bool value);
  
  // optional bool bbu_power_off = 2;
  inline bool has_bbu_power_off() const;
  inline void clear_bbu_power_off();
  static const int kBbuPowerOffFieldNumber = 2;
  inline bool bbu_power_off() const;
  inline void set_bbu_power_off(bool value);
  
  // optional bytes backup_path = 3;
  inline bool has_backup_path() const;
  inline void clear_backup_path();
  static const int kBackupPathFieldNumber = 3;
  inline const ::std::string& backup_path() const;
  inline void set_backup_path(const ::std::string& value);
  inline void set_backup_path(const char* value);
  inline void set_backup_path(const void* value, size_t size);
  inline ::std::string* mutable_backup_path();
  inline ::std::string* release_backup_path();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.AdminReq)
 private:
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_bbu_power_off();
  inline void clear_has_bbu_power_off();
  inline void set_has_backup_path();
  inline void clear_has_backup_path();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* backup_path_;
  bool stop_;
  bool bbu_power_off_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static AdminReq* default_instance_;
};
// -------------------------------------------------------------------

class AdminLoginReq : public ::google::protobuf::Message {
 public:
  AdminLoginReq();
  virtual ~AdminLoginReq();
  
  AdminLoginReq(const AdminLoginReq& from);
  
  inline AdminLoginReq& operator=(const AdminLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminLoginReq& default_instance();
  
  void Swap(AdminLoginReq* other);
  
  // implements Message ----------------------------------------------
  
  AdminLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminLoginReq& from);
  void MergeFrom(const AdminLoginReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:cdb_admin.AdminLoginReq)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_cdb_5fadmin_2eproto();
  friend void protobuf_AssignDesc_cdb_5fadmin_2eproto();
  friend void protobuf_ShutdownFile_cdb_5fadmin_2eproto();
  
  void InitAsDefaultInstance();
  static AdminLoginReq* default_instance_;
};
// ===================================================================


// ===================================================================

// AdminStatus

// required .cdb_admin.AdminStatus.ReturnCode code = 1 [default = OK];
inline bool AdminStatus::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminStatus::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminStatus::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminStatus::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::cdb_admin::AdminStatus_ReturnCode AdminStatus::code() const {
  return static_cast< ::cdb_admin::AdminStatus_ReturnCode >(code_);
}
inline void AdminStatus::set_code(::cdb_admin::AdminStatus_ReturnCode value) {
  GOOGLE_DCHECK(::cdb_admin::AdminStatus_ReturnCode_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string error = 2;
inline bool AdminStatus::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminStatus::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminStatus::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminStatus::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& AdminStatus::error() const {
  return *error_;
}
inline void AdminStatus::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void AdminStatus::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void AdminStatus::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminStatus::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* AdminStatus::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FormatDiskReq

// required string cluster_name = 1;
inline bool FormatDiskReq::has_cluster_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatDiskReq::set_has_cluster_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatDiskReq::clear_has_cluster_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatDiskReq::clear_cluster_name() {
  if (cluster_name_ != &::google::protobuf::internal::kEmptyString) {
    cluster_name_->clear();
  }
  clear_has_cluster_name();
}
inline const ::std::string& FormatDiskReq::cluster_name() const {
  return *cluster_name_;
}
inline void FormatDiskReq::set_cluster_name(const ::std::string& value) {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  cluster_name_->assign(value);
}
inline void FormatDiskReq::set_cluster_name(const char* value) {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  cluster_name_->assign(value);
}
inline void FormatDiskReq::set_cluster_name(const char* value, size_t size) {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  cluster_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatDiskReq::mutable_cluster_name() {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  return cluster_name_;
}
inline ::std::string* FormatDiskReq::release_cluster_name() {
  clear_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cluster_name_;
    cluster_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes cluster_uuid = 2;
inline bool FormatDiskReq::has_cluster_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormatDiskReq::set_has_cluster_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormatDiskReq::clear_has_cluster_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormatDiskReq::clear_cluster_uuid() {
  if (cluster_uuid_ != &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_->clear();
  }
  clear_has_cluster_uuid();
}
inline const ::std::string& FormatDiskReq::cluster_uuid() const {
  return *cluster_uuid_;
}
inline void FormatDiskReq::set_cluster_uuid(const ::std::string& value) {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  cluster_uuid_->assign(value);
}
inline void FormatDiskReq::set_cluster_uuid(const char* value) {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  cluster_uuid_->assign(value);
}
inline void FormatDiskReq::set_cluster_uuid(const void* value, size_t size) {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  cluster_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatDiskReq::mutable_cluster_uuid() {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  return cluster_uuid_;
}
inline ::std::string* FormatDiskReq::release_cluster_uuid() {
  clear_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cluster_uuid_;
    cluster_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string disk_uuid = 3;
inline bool FormatDiskReq::has_disk_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormatDiskReq::set_has_disk_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormatDiskReq::clear_has_disk_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormatDiskReq::clear_disk_uuid() {
  if (disk_uuid_ != &::google::protobuf::internal::kEmptyString) {
    disk_uuid_->clear();
  }
  clear_has_disk_uuid();
}
inline const ::std::string& FormatDiskReq::disk_uuid() const {
  return *disk_uuid_;
}
inline void FormatDiskReq::set_disk_uuid(const ::std::string& value) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(value);
}
inline void FormatDiskReq::set_disk_uuid(const char* value) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(value);
}
inline void FormatDiskReq::set_disk_uuid(const char* value, size_t size) {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  disk_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatDiskReq::mutable_disk_uuid() {
  set_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    disk_uuid_ = new ::std::string;
  }
  return disk_uuid_;
}
inline ::std::string* FormatDiskReq::release_disk_uuid() {
  clear_has_disk_uuid();
  if (disk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_uuid_;
    disk_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string disk_name = 4;
inline bool FormatDiskReq::has_disk_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormatDiskReq::set_has_disk_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormatDiskReq::clear_has_disk_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormatDiskReq::clear_disk_name() {
  if (disk_name_ != &::google::protobuf::internal::kEmptyString) {
    disk_name_->clear();
  }
  clear_has_disk_name();
}
inline const ::std::string& FormatDiskReq::disk_name() const {
  return *disk_name_;
}
inline void FormatDiskReq::set_disk_name(const ::std::string& value) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(value);
}
inline void FormatDiskReq::set_disk_name(const char* value) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(value);
}
inline void FormatDiskReq::set_disk_name(const char* value, size_t size) {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  disk_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatDiskReq::mutable_disk_name() {
  set_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    disk_name_ = new ::std::string;
  }
  return disk_name_;
}
inline ::std::string* FormatDiskReq::release_disk_name() {
  clear_has_disk_name();
  if (disk_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_name_;
    disk_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool force_format = 5 [default = false];
inline bool FormatDiskReq::has_force_format() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormatDiskReq::set_has_force_format() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormatDiskReq::clear_has_force_format() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormatDiskReq::clear_force_format() {
  force_format_ = false;
  clear_has_force_format();
}
inline bool FormatDiskReq::force_format() const {
  return force_format_;
}
inline void FormatDiskReq::set_force_format(bool value) {
  set_has_force_format();
  force_format_ = value;
}

// -------------------------------------------------------------------

// MetaNode

// required uint32 id = 1;
inline bool MetaNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaNode::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MetaNode::id() const {
  return id_;
}
inline void MetaNode::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 meta_port = 2;
inline bool MetaNode::has_meta_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaNode::set_has_meta_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaNode::clear_has_meta_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaNode::clear_meta_port() {
  meta_port_ = 0u;
  clear_has_meta_port();
}
inline ::google::protobuf::uint32 MetaNode::meta_port() const {
  return meta_port_;
}
inline void MetaNode::set_meta_port(::google::protobuf::uint32 value) {
  set_has_meta_port();
  meta_port_ = value;
}

// required uint32 election_port = 3;
inline bool MetaNode::has_election_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaNode::set_has_election_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaNode::clear_has_election_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaNode::clear_election_port() {
  election_port_ = 0u;
  clear_has_election_port();
}
inline ::google::protobuf::uint32 MetaNode::election_port() const {
  return election_port_;
}
inline void MetaNode::set_election_port(::google::protobuf::uint32 value) {
  set_has_election_port();
  election_port_ = value;
}

// required string primary_ip = 4;
inline bool MetaNode::has_primary_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetaNode::set_has_primary_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetaNode::clear_has_primary_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetaNode::clear_primary_ip() {
  if (primary_ip_ != &::google::protobuf::internal::kEmptyString) {
    primary_ip_->clear();
  }
  clear_has_primary_ip();
}
inline const ::std::string& MetaNode::primary_ip() const {
  return *primary_ip_;
}
inline void MetaNode::set_primary_ip(const ::std::string& value) {
  set_has_primary_ip();
  if (primary_ip_ == &::google::protobuf::internal::kEmptyString) {
    primary_ip_ = new ::std::string;
  }
  primary_ip_->assign(value);
}
inline void MetaNode::set_primary_ip(const char* value) {
  set_has_primary_ip();
  if (primary_ip_ == &::google::protobuf::internal::kEmptyString) {
    primary_ip_ = new ::std::string;
  }
  primary_ip_->assign(value);
}
inline void MetaNode::set_primary_ip(const char* value, size_t size) {
  set_has_primary_ip();
  if (primary_ip_ == &::google::protobuf::internal::kEmptyString) {
    primary_ip_ = new ::std::string;
  }
  primary_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaNode::mutable_primary_ip() {
  set_has_primary_ip();
  if (primary_ip_ == &::google::protobuf::internal::kEmptyString) {
    primary_ip_ = new ::std::string;
  }
  return primary_ip_;
}
inline ::std::string* MetaNode::release_primary_ip() {
  clear_has_primary_ip();
  if (primary_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primary_ip_;
    primary_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string secondary_ip = 5;
inline bool MetaNode::has_secondary_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetaNode::set_has_secondary_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetaNode::clear_has_secondary_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetaNode::clear_secondary_ip() {
  if (secondary_ip_ != &::google::protobuf::internal::kEmptyString) {
    secondary_ip_->clear();
  }
  clear_has_secondary_ip();
}
inline const ::std::string& MetaNode::secondary_ip() const {
  return *secondary_ip_;
}
inline void MetaNode::set_secondary_ip(const ::std::string& value) {
  set_has_secondary_ip();
  if (secondary_ip_ == &::google::protobuf::internal::kEmptyString) {
    secondary_ip_ = new ::std::string;
  }
  secondary_ip_->assign(value);
}
inline void MetaNode::set_secondary_ip(const char* value) {
  set_has_secondary_ip();
  if (secondary_ip_ == &::google::protobuf::internal::kEmptyString) {
    secondary_ip_ = new ::std::string;
  }
  secondary_ip_->assign(value);
}
inline void MetaNode::set_secondary_ip(const char* value, size_t size) {
  set_has_secondary_ip();
  if (secondary_ip_ == &::google::protobuf::internal::kEmptyString) {
    secondary_ip_ = new ::std::string;
  }
  secondary_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaNode::mutable_secondary_ip() {
  set_has_secondary_ip();
  if (secondary_ip_ == &::google::protobuf::internal::kEmptyString) {
    secondary_ip_ = new ::std::string;
  }
  return secondary_ip_;
}
inline ::std::string* MetaNode::release_secondary_ip() {
  clear_has_secondary_ip();
  if (secondary_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_ip_;
    secondary_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MetaCluster

// required string cluster_name = 1;
inline bool MetaCluster::has_cluster_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaCluster::set_has_cluster_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaCluster::clear_has_cluster_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaCluster::clear_cluster_name() {
  if (cluster_name_ != &::google::protobuf::internal::kEmptyString) {
    cluster_name_->clear();
  }
  clear_has_cluster_name();
}
inline const ::std::string& MetaCluster::cluster_name() const {
  return *cluster_name_;
}
inline void MetaCluster::set_cluster_name(const ::std::string& value) {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  cluster_name_->assign(value);
}
inline void MetaCluster::set_cluster_name(const char* value) {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  cluster_name_->assign(value);
}
inline void MetaCluster::set_cluster_name(const char* value, size_t size) {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  cluster_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaCluster::mutable_cluster_name() {
  set_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    cluster_name_ = new ::std::string;
  }
  return cluster_name_;
}
inline ::std::string* MetaCluster::release_cluster_name() {
  clear_has_cluster_name();
  if (cluster_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cluster_name_;
    cluster_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes cluster_uuid = 2;
inline bool MetaCluster::has_cluster_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaCluster::set_has_cluster_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaCluster::clear_has_cluster_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaCluster::clear_cluster_uuid() {
  if (cluster_uuid_ != &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_->clear();
  }
  clear_has_cluster_uuid();
}
inline const ::std::string& MetaCluster::cluster_uuid() const {
  return *cluster_uuid_;
}
inline void MetaCluster::set_cluster_uuid(const ::std::string& value) {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  cluster_uuid_->assign(value);
}
inline void MetaCluster::set_cluster_uuid(const char* value) {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  cluster_uuid_->assign(value);
}
inline void MetaCluster::set_cluster_uuid(const void* value, size_t size) {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  cluster_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaCluster::mutable_cluster_uuid() {
  set_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    cluster_uuid_ = new ::std::string;
  }
  return cluster_uuid_;
}
inline ::std::string* MetaCluster::release_cluster_uuid() {
  clear_has_cluster_uuid();
  if (cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cluster_uuid_;
    cluster_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 meta_service_port = 3;
inline bool MetaCluster::has_meta_service_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaCluster::set_has_meta_service_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaCluster::clear_has_meta_service_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaCluster::clear_meta_service_port() {
  meta_service_port_ = 0u;
  clear_has_meta_service_port();
}
inline ::google::protobuf::uint32 MetaCluster::meta_service_port() const {
  return meta_service_port_;
}
inline void MetaCluster::set_meta_service_port(::google::protobuf::uint32 value) {
  set_has_meta_service_port();
  meta_service_port_ = value;
}

// repeated .cdb_admin.MetaNode node = 4;
inline int MetaCluster::node_size() const {
  return node_.size();
}
inline void MetaCluster::clear_node() {
  node_.Clear();
}
inline const ::cdb_admin::MetaNode& MetaCluster::node(int index) const {
  return node_.Get(index);
}
inline ::cdb_admin::MetaNode* MetaCluster::mutable_node(int index) {
  return node_.Mutable(index);
}
inline ::cdb_admin::MetaNode* MetaCluster::add_node() {
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cdb_admin::MetaNode >&
MetaCluster::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::cdb_admin::MetaNode >*
MetaCluster::mutable_node() {
  return &node_;
}

// -------------------------------------------------------------------

// MetaServerConf

// required .cdb_admin.MetaCluster cluster = 1;
inline bool MetaServerConf::has_cluster() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaServerConf::set_has_cluster() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaServerConf::clear_has_cluster() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaServerConf::clear_cluster() {
  if (cluster_ != NULL) cluster_->::cdb_admin::MetaCluster::Clear();
  clear_has_cluster();
}
inline const ::cdb_admin::MetaCluster& MetaServerConf::cluster() const {
  return cluster_ != NULL ? *cluster_ : *default_instance_->cluster_;
}
inline ::cdb_admin::MetaCluster* MetaServerConf::mutable_cluster() {
  set_has_cluster();
  if (cluster_ == NULL) cluster_ = new ::cdb_admin::MetaCluster;
  return cluster_;
}
inline ::cdb_admin::MetaCluster* MetaServerConf::release_cluster() {
  clear_has_cluster();
  ::cdb_admin::MetaCluster* temp = cluster_;
  cluster_ = NULL;
  return temp;
}

// required uint32 my_id = 2;
inline bool MetaServerConf::has_my_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaServerConf::set_has_my_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaServerConf::clear_has_my_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaServerConf::clear_my_id() {
  my_id_ = 0u;
  clear_has_my_id();
}
inline ::google::protobuf::uint32 MetaServerConf::my_id() const {
  return my_id_;
}
inline void MetaServerConf::set_my_id(::google::protobuf::uint32 value) {
  set_has_my_id();
  my_id_ = value;
}

// required string db_disk_name = 3;
inline bool MetaServerConf::has_db_disk_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaServerConf::set_has_db_disk_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaServerConf::clear_has_db_disk_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaServerConf::clear_db_disk_name() {
  if (db_disk_name_ != &::google::protobuf::internal::kEmptyString) {
    db_disk_name_->clear();
  }
  clear_has_db_disk_name();
}
inline const ::std::string& MetaServerConf::db_disk_name() const {
  return *db_disk_name_;
}
inline void MetaServerConf::set_db_disk_name(const ::std::string& value) {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  db_disk_name_->assign(value);
}
inline void MetaServerConf::set_db_disk_name(const char* value) {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  db_disk_name_->assign(value);
}
inline void MetaServerConf::set_db_disk_name(const char* value, size_t size) {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  db_disk_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaServerConf::mutable_db_disk_name() {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  return db_disk_name_;
}
inline ::std::string* MetaServerConf::release_db_disk_name() {
  clear_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = db_disk_name_;
    db_disk_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string db_ram_cache_dir = 5;
inline bool MetaServerConf::has_db_ram_cache_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetaServerConf::set_has_db_ram_cache_dir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetaServerConf::clear_has_db_ram_cache_dir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetaServerConf::clear_db_ram_cache_dir() {
  if (db_ram_cache_dir_ != &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_->clear();
  }
  clear_has_db_ram_cache_dir();
}
inline const ::std::string& MetaServerConf::db_ram_cache_dir() const {
  return *db_ram_cache_dir_;
}
inline void MetaServerConf::set_db_ram_cache_dir(const ::std::string& value) {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  db_ram_cache_dir_->assign(value);
}
inline void MetaServerConf::set_db_ram_cache_dir(const char* value) {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  db_ram_cache_dir_->assign(value);
}
inline void MetaServerConf::set_db_ram_cache_dir(const char* value, size_t size) {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  db_ram_cache_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaServerConf::mutable_db_ram_cache_dir() {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  return db_ram_cache_dir_;
}
inline ::std::string* MetaServerConf::release_db_ram_cache_dir() {
  clear_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = db_ram_cache_dir_;
    db_ram_cache_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string local_backup_dir = 6;
inline bool MetaServerConf::has_local_backup_dir() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetaServerConf::set_has_local_backup_dir() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetaServerConf::clear_has_local_backup_dir() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetaServerConf::clear_local_backup_dir() {
  if (local_backup_dir_ != &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_->clear();
  }
  clear_has_local_backup_dir();
}
inline const ::std::string& MetaServerConf::local_backup_dir() const {
  return *local_backup_dir_;
}
inline void MetaServerConf::set_local_backup_dir(const ::std::string& value) {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  local_backup_dir_->assign(value);
}
inline void MetaServerConf::set_local_backup_dir(const char* value) {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  local_backup_dir_->assign(value);
}
inline void MetaServerConf::set_local_backup_dir(const char* value, size_t size) {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  local_backup_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaServerConf::mutable_local_backup_dir() {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  return local_backup_dir_;
}
inline ::std::string* MetaServerConf::release_local_backup_dir() {
  clear_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = local_backup_dir_;
    local_backup_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool has_bbu = 7;
inline bool MetaServerConf::has_has_bbu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetaServerConf::set_has_has_bbu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetaServerConf::clear_has_has_bbu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetaServerConf::clear_has_bbu() {
  has_bbu_ = false;
  clear_has_has_bbu();
}
inline bool MetaServerConf::has_bbu() const {
  return has_bbu_;
}
inline void MetaServerConf::set_has_bbu(bool value) {
  set_has_has_bbu();
  has_bbu_ = value;
}

// -------------------------------------------------------------------

// ChunkServerConf

// required .cdb_admin.MetaCluster cluster = 1;
inline bool ChunkServerConf::has_cluster() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChunkServerConf::set_has_cluster() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChunkServerConf::clear_has_cluster() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChunkServerConf::clear_cluster() {
  if (cluster_ != NULL) cluster_->::cdb_admin::MetaCluster::Clear();
  clear_has_cluster();
}
inline const ::cdb_admin::MetaCluster& ChunkServerConf::cluster() const {
  return cluster_ != NULL ? *cluster_ : *default_instance_->cluster_;
}
inline ::cdb_admin::MetaCluster* ChunkServerConf::mutable_cluster() {
  set_has_cluster();
  if (cluster_ == NULL) cluster_ = new ::cdb_admin::MetaCluster;
  return cluster_;
}
inline ::cdb_admin::MetaCluster* ChunkServerConf::release_cluster() {
  clear_has_cluster();
  ::cdb_admin::MetaCluster* temp = cluster_;
  cluster_ = NULL;
  return temp;
}

// required uint32 chunk_port = 2;
inline bool ChunkServerConf::has_chunk_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChunkServerConf::set_has_chunk_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChunkServerConf::clear_has_chunk_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChunkServerConf::clear_chunk_port() {
  chunk_port_ = 0u;
  clear_has_chunk_port();
}
inline ::google::protobuf::uint32 ChunkServerConf::chunk_port() const {
  return chunk_port_;
}
inline void ChunkServerConf::set_chunk_port(::google::protobuf::uint32 value) {
  set_has_chunk_port();
  chunk_port_ = value;
}

// repeated string chunk_ips = 3;
inline int ChunkServerConf::chunk_ips_size() const {
  return chunk_ips_.size();
}
inline void ChunkServerConf::clear_chunk_ips() {
  chunk_ips_.Clear();
}
inline const ::std::string& ChunkServerConf::chunk_ips(int index) const {
  return chunk_ips_.Get(index);
}
inline ::std::string* ChunkServerConf::mutable_chunk_ips(int index) {
  return chunk_ips_.Mutable(index);
}
inline void ChunkServerConf::set_chunk_ips(int index, const ::std::string& value) {
  chunk_ips_.Mutable(index)->assign(value);
}
inline void ChunkServerConf::set_chunk_ips(int index, const char* value) {
  chunk_ips_.Mutable(index)->assign(value);
}
inline void ChunkServerConf::set_chunk_ips(int index, const char* value, size_t size) {
  chunk_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerConf::add_chunk_ips() {
  return chunk_ips_.Add();
}
inline void ChunkServerConf::add_chunk_ips(const ::std::string& value) {
  chunk_ips_.Add()->assign(value);
}
inline void ChunkServerConf::add_chunk_ips(const char* value) {
  chunk_ips_.Add()->assign(value);
}
inline void ChunkServerConf::add_chunk_ips(const char* value, size_t size) {
  chunk_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChunkServerConf::chunk_ips() const {
  return chunk_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChunkServerConf::mutable_chunk_ips() {
  return &chunk_ips_;
}

// required string db_disk_name = 4;
inline bool ChunkServerConf::has_db_disk_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChunkServerConf::set_has_db_disk_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChunkServerConf::clear_has_db_disk_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChunkServerConf::clear_db_disk_name() {
  if (db_disk_name_ != &::google::protobuf::internal::kEmptyString) {
    db_disk_name_->clear();
  }
  clear_has_db_disk_name();
}
inline const ::std::string& ChunkServerConf::db_disk_name() const {
  return *db_disk_name_;
}
inline void ChunkServerConf::set_db_disk_name(const ::std::string& value) {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  db_disk_name_->assign(value);
}
inline void ChunkServerConf::set_db_disk_name(const char* value) {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  db_disk_name_->assign(value);
}
inline void ChunkServerConf::set_db_disk_name(const char* value, size_t size) {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  db_disk_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerConf::mutable_db_disk_name() {
  set_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    db_disk_name_ = new ::std::string;
  }
  return db_disk_name_;
}
inline ::std::string* ChunkServerConf::release_db_disk_name() {
  clear_has_db_disk_name();
  if (db_disk_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = db_disk_name_;
    db_disk_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string db_ram_cache_dir = 5;
inline bool ChunkServerConf::has_db_ram_cache_dir() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChunkServerConf::set_has_db_ram_cache_dir() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChunkServerConf::clear_has_db_ram_cache_dir() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChunkServerConf::clear_db_ram_cache_dir() {
  if (db_ram_cache_dir_ != &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_->clear();
  }
  clear_has_db_ram_cache_dir();
}
inline const ::std::string& ChunkServerConf::db_ram_cache_dir() const {
  return *db_ram_cache_dir_;
}
inline void ChunkServerConf::set_db_ram_cache_dir(const ::std::string& value) {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  db_ram_cache_dir_->assign(value);
}
inline void ChunkServerConf::set_db_ram_cache_dir(const char* value) {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  db_ram_cache_dir_->assign(value);
}
inline void ChunkServerConf::set_db_ram_cache_dir(const char* value, size_t size) {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  db_ram_cache_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerConf::mutable_db_ram_cache_dir() {
  set_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    db_ram_cache_dir_ = new ::std::string;
  }
  return db_ram_cache_dir_;
}
inline ::std::string* ChunkServerConf::release_db_ram_cache_dir() {
  clear_has_db_ram_cache_dir();
  if (db_ram_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = db_ram_cache_dir_;
    db_ram_cache_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string local_backup_dir = 6;
inline bool ChunkServerConf::has_local_backup_dir() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChunkServerConf::set_has_local_backup_dir() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChunkServerConf::clear_has_local_backup_dir() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChunkServerConf::clear_local_backup_dir() {
  if (local_backup_dir_ != &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_->clear();
  }
  clear_has_local_backup_dir();
}
inline const ::std::string& ChunkServerConf::local_backup_dir() const {
  return *local_backup_dir_;
}
inline void ChunkServerConf::set_local_backup_dir(const ::std::string& value) {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  local_backup_dir_->assign(value);
}
inline void ChunkServerConf::set_local_backup_dir(const char* value) {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  local_backup_dir_->assign(value);
}
inline void ChunkServerConf::set_local_backup_dir(const char* value, size_t size) {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  local_backup_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerConf::mutable_local_backup_dir() {
  set_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    local_backup_dir_ = new ::std::string;
  }
  return local_backup_dir_;
}
inline ::std::string* ChunkServerConf::release_local_backup_dir() {
  clear_has_local_backup_dir();
  if (local_backup_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = local_backup_dir_;
    local_backup_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool has_bbu = 7;
inline bool ChunkServerConf::has_has_bbu() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChunkServerConf::set_has_has_bbu() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChunkServerConf::clear_has_has_bbu() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChunkServerConf::clear_has_bbu() {
  has_bbu_ = false;
  clear_has_has_bbu();
}
inline bool ChunkServerConf::has_bbu() const {
  return has_bbu_;
}
inline void ChunkServerConf::set_has_bbu(bool value) {
  set_has_has_bbu();
  has_bbu_ = value;
}

// optional string zone_name = 8;
inline bool ChunkServerConf::has_zone_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChunkServerConf::set_has_zone_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChunkServerConf::clear_has_zone_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChunkServerConf::clear_zone_name() {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    zone_name_->clear();
  }
  clear_has_zone_name();
}
inline const ::std::string& ChunkServerConf::zone_name() const {
  return *zone_name_;
}
inline void ChunkServerConf::set_zone_name(const ::std::string& value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void ChunkServerConf::set_zone_name(const char* value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void ChunkServerConf::set_zone_name(const char* value, size_t size) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerConf::mutable_zone_name() {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  return zone_name_;
}
inline ::std::string* ChunkServerConf::release_zone_name() {
  clear_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_name_;
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string machine_id = 9;
inline bool ChunkServerConf::has_machine_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChunkServerConf::set_has_machine_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChunkServerConf::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChunkServerConf::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& ChunkServerConf::machine_id() const {
  return *machine_id_;
}
inline void ChunkServerConf::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ChunkServerConf::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ChunkServerConf::set_machine_id(const char* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkServerConf::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* ChunkServerConf::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StatMetaReq

// required string user = 1;
inline bool StatMetaReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatMetaReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatMetaReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatMetaReq::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& StatMetaReq::user() const {
  return *user_;
}
inline void StatMetaReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void StatMetaReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void StatMetaReq::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatMetaReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* StatMetaReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool StatMetaReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatMetaReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatMetaReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatMetaReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& StatMetaReq::password() const {
  return *password_;
}
inline void StatMetaReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void StatMetaReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void StatMetaReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatMetaReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* StatMetaReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MetaStat

// required .cdb_admin.MetaState state = 1;
inline bool MetaStat::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaStat::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaStat::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaStat::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline cdb_admin::MetaState MetaStat::state() const {
  return static_cast< cdb_admin::MetaState >(state_);
}
inline void MetaStat::set_state(cdb_admin::MetaState value) {
  GOOGLE_DCHECK(cdb_admin::MetaState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint32 leader_id = 2;
inline bool MetaStat::has_leader_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaStat::set_has_leader_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaStat::clear_has_leader_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaStat::clear_leader_id() {
  leader_id_ = 0u;
  clear_has_leader_id();
}
inline ::google::protobuf::uint32 MetaStat::leader_id() const {
  return leader_id_;
}
inline void MetaStat::set_leader_id(::google::protobuf::uint32 value) {
  set_has_leader_id();
  leader_id_ = value;
}

// optional .MetaDiskStat meta_disk = 3;
inline bool MetaStat::has_meta_disk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaStat::set_has_meta_disk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaStat::clear_has_meta_disk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaStat::clear_meta_disk() {
  if (meta_disk_ != NULL) meta_disk_->::MetaDiskStat::Clear();
  clear_has_meta_disk();
}
inline const ::MetaDiskStat& MetaStat::meta_disk() const {
  return meta_disk_ != NULL ? *meta_disk_ : *default_instance_->meta_disk_;
}
inline ::MetaDiskStat* MetaStat::mutable_meta_disk() {
  set_has_meta_disk();
  if (meta_disk_ == NULL) meta_disk_ = new ::MetaDiskStat;
  return meta_disk_;
}
inline ::MetaDiskStat* MetaStat::release_meta_disk() {
  clear_has_meta_disk();
  ::MetaDiskStat* temp = meta_disk_;
  meta_disk_ = NULL;
  return temp;
}

// optional bytes internal_cluster_uuid = 4;
inline bool MetaStat::has_internal_cluster_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetaStat::set_has_internal_cluster_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetaStat::clear_has_internal_cluster_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetaStat::clear_internal_cluster_uuid() {
  if (internal_cluster_uuid_ != &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_->clear();
  }
  clear_has_internal_cluster_uuid();
}
inline const ::std::string& MetaStat::internal_cluster_uuid() const {
  return *internal_cluster_uuid_;
}
inline void MetaStat::set_internal_cluster_uuid(const ::std::string& value) {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  internal_cluster_uuid_->assign(value);
}
inline void MetaStat::set_internal_cluster_uuid(const char* value) {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  internal_cluster_uuid_->assign(value);
}
inline void MetaStat::set_internal_cluster_uuid(const void* value, size_t size) {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  internal_cluster_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaStat::mutable_internal_cluster_uuid() {
  set_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    internal_cluster_uuid_ = new ::std::string;
  }
  return internal_cluster_uuid_;
}
inline ::std::string* MetaStat::release_internal_cluster_uuid() {
  clear_has_internal_cluster_uuid();
  if (internal_cluster_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internal_cluster_uuid_;
    internal_cluster_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes version = 5;
inline bool MetaStat::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetaStat::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetaStat::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetaStat::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& MetaStat::version() const {
  return *version_;
}
inline void MetaStat::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void MetaStat::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void MetaStat::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaStat::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* MetaStat::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AdminReq

// optional bool stop = 1;
inline bool AdminReq::has_stop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminReq::set_has_stop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminReq::clear_has_stop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminReq::clear_stop() {
  stop_ = false;
  clear_has_stop();
}
inline bool AdminReq::stop() const {
  return stop_;
}
inline void AdminReq::set_stop(bool value) {
  set_has_stop();
  stop_ = value;
}

// optional bool bbu_power_off = 2;
inline bool AdminReq::has_bbu_power_off() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminReq::set_has_bbu_power_off() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminReq::clear_has_bbu_power_off() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminReq::clear_bbu_power_off() {
  bbu_power_off_ = false;
  clear_has_bbu_power_off();
}
inline bool AdminReq::bbu_power_off() const {
  return bbu_power_off_;
}
inline void AdminReq::set_bbu_power_off(bool value) {
  set_has_bbu_power_off();
  bbu_power_off_ = value;
}

// optional bytes backup_path = 3;
inline bool AdminReq::has_backup_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdminReq::set_has_backup_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdminReq::clear_has_backup_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdminReq::clear_backup_path() {
  if (backup_path_ != &::google::protobuf::internal::kEmptyString) {
    backup_path_->clear();
  }
  clear_has_backup_path();
}
inline const ::std::string& AdminReq::backup_path() const {
  return *backup_path_;
}
inline void AdminReq::set_backup_path(const ::std::string& value) {
  set_has_backup_path();
  if (backup_path_ == &::google::protobuf::internal::kEmptyString) {
    backup_path_ = new ::std::string;
  }
  backup_path_->assign(value);
}
inline void AdminReq::set_backup_path(const char* value) {
  set_has_backup_path();
  if (backup_path_ == &::google::protobuf::internal::kEmptyString) {
    backup_path_ = new ::std::string;
  }
  backup_path_->assign(value);
}
inline void AdminReq::set_backup_path(const void* value, size_t size) {
  set_has_backup_path();
  if (backup_path_ == &::google::protobuf::internal::kEmptyString) {
    backup_path_ = new ::std::string;
  }
  backup_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminReq::mutable_backup_path() {
  set_has_backup_path();
  if (backup_path_ == &::google::protobuf::internal::kEmptyString) {
    backup_path_ = new ::std::string;
  }
  return backup_path_;
}
inline ::std::string* AdminReq::release_backup_path() {
  clear_has_backup_path();
  if (backup_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backup_path_;
    backup_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AdminLoginReq

// required bytes version = 1;
inline bool AdminLoginReq::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminLoginReq::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminLoginReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminLoginReq::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AdminLoginReq::version() const {
  return *version_;
}
inline void AdminLoginReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AdminLoginReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AdminLoginReq::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminLoginReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AdminLoginReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cdb_admin

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cdb_admin::AdminStatus_ReturnCode>() {
  return ::cdb_admin::AdminStatus_ReturnCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< cdb_admin::MetaState>() {
  return cdb_admin::MetaState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cdb_5fadmin_2eproto__INCLUDED
